# C 本体

> 所谓本体就是语言原生支持的操作，无需借助任何外部程序，包括标准库的程序

## 引言

* 本体不支持
  * 复合数据结构直接处理
    * C语言不提供直接处理诸如字符串、集合、列表或数据等复合对象的操作。虽然可以将整个结构作为一个单元进行拷贝，但C语言没有处理整个数组或字符串的操作。
  * 存储管理
    * 除了由函数的局部变量提供的静态定义和堆栈外，C语言没有定义任何存储器分配工具，也不提供堆和无用内存回收工具。
  * 输入输出
    * C语言本身没有提供IO功能，没有READ或WRITE语句，也没有内置的文件访问方法。所有这些高层的机制必须由显式调用的函数提供。
  * 并行
    * C语言只提供简单的单线程控制流，即测试、循环、分组和子程序，它不提供多道程序设计、并行操作、同步和协同例程。
* 语言学家？
  * 有关编程语言的官方标准，即最全最准最细的语言介绍，是给编译器实现者看的，不是给普通程序员看的，所以我们没必要了解所有细节，大概知道整个知识树，用什么细节钻研什么细节就行了。
  * 所以笔记没必要奢求一次性把所有相关只是内容记下来，只需第一遍填充整体的框架，然后以后一遍一遍根据实际应用填充细节即可。

# 1 变量

> 变量或者说数据结构就是语言提供给我们的**可以读写的一块内存的抽象**，仅此而已。

## 1.1 概念

### 1.1.1 内存抽象

* 字节数组
  * 对于程序而言，内存就是一个巨大的字节数组，下标是从0x0000000000000000(64位机器)开始的地址，值是8bit的位pattern。
* 键值对
  * 内存就是一个数组，换言之就是键值对，键是下标，值是值。
  * **所以底层对于内存的访问永远是靠键，即地址。**
  * 语言提供的抽象也是键值对，并且通过键来使用值
    * 只不过语言提供的所谓<变量名-值>、<引用-值>、<指针-值>等键值对
    * 其键的底层本质都是地址访问，只不过编译器隐藏了这一点然后给我们提供抽象罢了。

### 1.1.2 所谓变量类型

* 所有类型变量的值都是位模式
* 对象的类型决定该对象的取值的集合以及可以对该对象执行的操作

### 1.1.3 变量、常量、字面值

##### 1. 变量

* 很好理解，值可以变得就是变量
* **变量的值在运行时确定**

##### 2. 常量

* 定义
  * 硬件上一块内存总是可以读写的，所以其抽象叫做变量
  * 出于软件需要，有时要限制变量的修改，那么这个被限制修改的“变量”就是常量
  * **常量的值在编译时确定**
* 分类
  * 字面值常量
  * const 常量
  * #define 常量
  * 常量表达式
  * 枚举常量

##### 3.字面值

*  定义

  * 一种特殊的“变量”，它的键十分特殊，特殊在两点
  
    *  它的键就是它的值的，所以叫字面值。
    *  我们只能读存储字面值的这块内存，而无法修改，因为它是匿名的。
  
* 分类
  
    * 数值字面值
    
      *  不加引号的表示数字字面值
      *  整数支持十进制，八进制(0开头)，十六进制(0x开头，大小写都行)
      *  浮点数支持小数点形式和科学计数法形式
    
  * 字符字面值
      
      * 单引号表示字符字面值
    * 支持常规可输入字符和转义序列
    
  * 字符串字面值
  
    *  双引号表示字符串字面值。
  
    * ```c
    int c=10，b=08，c=0xFF;
    char ch='a',chc='\n',chcc='\123',chccc='011';
    char * str="nmsl"
    ```
  
* 使用

  *  字面值见名知义，十分方便
  *  但是凡是有一定意义的字面值，最好不要随处卵用，例如要用"hello world"作为问候语
  *  那么相比随处乱用，最好定义一个符号常量使用它
    *  #define   HELLO   "hello world"
    *  预处理器会把所有出现HELLO的地方替换为"hello world",相当于全局搜索替换文本。


### 1.1.4 声明、定义、初始化

> declaration , define，initialization

##### 1.声明

* 不给变量分配内存，仅仅声明变量名字和性质。
* 可以理解为声明了键，但是没有对应的值

##### 2.定义

* 意义

  * 声明变量、分配内存、构造变量并初始化

  * 可以理解为生成了一个键值对

* 形式

  * [限定符]  变量类型 变量名;
  * [限定符]  变量类型 变量名1, 变量名2,....;
  * [限定符]  变量类型 变量名=值;

##### 3.初始化

* 定义变量的时候会执行变量初始化
* 初始化类型
  * 默认初始化
    * 对于局部变量而言就是随机值
    * 对于全局变量和静态变量就是0.
    * 对于结构，类等复杂变量而言就是构造函数设定的默认值。
  * 赋值初始化
    * 字面值赋值
    * 变量赋值

### 1.1.5 全局变量和局部变量

#### 1. 局部变量

* 函数内定义的变量
* 因为只在函数执行时创建，执行完毕后销毁，所以也叫自动变量

#### 2. 全局变量

* 定义在所有函数之外，且只能定义一次，由编译程序分配存储单元
* 定义时默认初始化为0，赋值初始化的话必须用常量表达式初始化。
* 定义在所有函数之外，所以也叫外部变量

### 1.1.6 生存期和作用域

#### 1. 生存期

> 生存期指变量所在内存块没被释放的这段时间

* 全局变量
  * 编译时创建-程序结束时释放
  * 即生存期等于程序生存期。
* 局部变量
  * 函数执行时创建-函数执行完毕释放

#### 2. 作用域

> 就是变量名这个键的作用范围

* 全局变量

  * 全局作用域，所有源文件都可使用

    * 定义全局变量的文件可以直接使用

    * 其他文件需要先声明后使用。

      * ```c
        //file1.c
        int test;
        int main()
        {}
        //file2.c
        extern int test;
        int main()
        {test=10;}
        ```

* 局部变量

  * 块作用域，块儿内使用

## 1.2 分类

### 1.2.1 数值变量

#### 1. 类型和范围

* 整型

  * | Type           | C语言要求至少 | 32位硬件典型实现 | 64位硬件典型实现 |
    | -------------- | ------------- | ---------------- | ---------------- |
    | char           | 8bit          | 8bit             | 8bit             |
    | signed char    | 8             | 8                | 8                |
    | unsigned char  | 8             | 8                | 8                |
    | short          | 16            | 16               | 16               |
    | unsigned short | 16            | 16               | 16               |
    | int            | 16            | 32               | 32               |
    | unsigned int   | 16            | 32               | 32               |
    | long           | 32            | 32               | 64               |
    | unsigned long  | 32            | 32               | 64               |

    * C语言要求short和int最少16位，long最少32位，short不能长于int，int不能长于long
    * short和long是 short int 和long int的简写。
    * 具体实现由编译器根据对应硬件平台决定。
    
  * 整型字面值
  
    * 支持十进制普通形式、科学计数法形式，八进制，十六进制  
  
      * 八进制0开头，012，十六进制0x开头(大小写均可)
  
      * ```c
        int a=10, b=012,c=0xff,d=0xFF;
        long nb=2e10;  //2e10表示2乘以10的10次方。
        ```
  
      * 
  
    * 整型字面值的匿名存储对象默认是int类型，如果超范围了，那么就用long类型，也可以手动指定
  
      * l和L结尾，手动指定匿名存储对象为有符号long类型，用8B存储
  
      * u和U结尾，指定为无符号类型
  
        * ```c
          long x=123l,y=133L;
          long x=233ul,y=23u;
          ```
  
  * 字符变量
  
    * 字符变量是比较特殊的一种整型变量，普通整型变量按照2的补码解释，字符变量按照ASCII解释。
  
    * ASCII只定义了7位，所以字符变量的范围限定为0x00~0x7F。
  
    * 字符字面值
  
      * 键盘可直接输入的那么包在单引号内直接输入即可。
  
      * 无法直接输入或者无法显示的字符，可以用转义序列表示。
  
      * 常用转义序列
  
        * | 序列  | 字符           | 序列        | 字符                                            |
          | ----- | -------------- | ----------- | ----------------------------------------------- |
          | '\\n' | 换行           | '\\r'       | 回车                                            |
          | '\\0' | 空字符null     | '\\ooo'     | ASCII中八进制数对应的字符                       |
          | '\\t' | 制表符         | '\\xhh'     | 16进制数对应的字符(16进制大小写都行\\x1F,\\x1f) |
          | '\\?' | 问号也要转义。 | '\\'','\\"' | 单双引号转义                                    |
  
* 浮点型

  * | Type        | 32位硬件典型实现 | 64位硬件典型实现 |
    | ----------- | ---------------- | ---------------- |
    | float       | 4B               | 4B               |
    | double      | 8B               | 8B               |
    | long double | 8B               | 16B              |

    * float 单精度浮点数，double双精度浮点数
    * 具体范围取决于机器。
    
  * 浮点数字面值
  
    * 支持小数点形式和科学计数法形式
  
      * ```c
        double a=0.01   <==>   double a=1e-2   //(1乘以10的负二次方)
        ```
  
    * 默认字面值匿名存储对象类型为double
  
      * 后缀f和F指定为float型
      * 后缀l或L指定为long double类型
        * 如果字面值不是小数，加后缀l，L表示long 型整数，如果是小数表示long double型浮点数。

#### 2. 定义

* [限定符]  整型类型  变量名；

* 浮点类型 变量名；

  * ```c
    signed int a;	
    unsigned int a,b;
    int a=10;
    int a=10,b=20;
    int a=b;
    
    //构建没有初始化，值为随机值
    char var1
    //构建并以字面值初始化，转义字符斜杠用来表示无法输入的或无法显示的字符字面值
    char var1='a',var2='\n',var3='\"', var4='\0',var5='\123'
    //构建并以字符变量初始化。
    char var1='a'
    char var2=var1
    ```
  
  * 限定符signed和unsigned用于整型变量，表示有符号或无符号，省略限定符那么表示有符号，char除外，char取决于机器。

### 1.2.2 枚举

* ```c
  enum names {LP,SSY,ABC};
  enum {SB,CNM,YYDS};
  enum {XX,LP=2, CC=4, DD，FF}; // XX值为1，DD值为5， FF为6
  ```

  * 第一个定义了枚举变量names,3个int型常量LP，SSY，ABC，并且限定names的取值范围只能是这三个整型常量值。
  * 第二个就是定义了三个int整型常量，建立了名字与0，1，2字面值常量之间的联系。
  * 整型常量值没指定默认从0开始递增，如果指定了，那么没指定的那些从最近的指定了的处递增

### 1.2.3 数组变量

#### 0. 数组 

#### 1. 数值数组

#### 2. 字符数组



# 2 函数

> function

## 2.1 声明和定义

## 2.2 参数

* 值传递
  * C语言只有一种传参方式就是值传递。
  * **本质就是被调函数利用其调用者的实际参数赋值初始化自己的形式参数。**

## 2.3 返回值

* 每个函数都有返回值，除了main函数之外的所有函数返回值返回给其调用者函数。
* main函数的返回值返回给其执行环境。
  * 类似shell中执行ls，ls返回值返回给其执行环境shell

# 3 表达式

## 3.1 定义

* 表达式与语句

  * 除声明定义语句以外，**任何一个去掉分号的语句就是一个表达式**
  * 所以一个单一的变量也是一个表达式。
  * 换言之，任何一个表达式(expression)加上分号就是一个语句(statement).

* 表达式形式

  * 操作符+操作数

  * 操作数

    * 表达式允许嵌套，即表达式本身可以作为操作数

    * ```c
      int a,b;
      a+b;   //操作符+操作数型
      a;	   //操作数型
      ```
  
* **表达式的值**

  * 不管使用表达式与否，只要表达式出现在程序执行流程中，
  * 程序都会对表达式求一个值，所以每个表达式都有一个值
  * 既然有值，那么就有存储对象，所以每个表达式都会有一个匿名对象存储表达式的值
    * **所以一个表达式其实语法上就类似一个"变量"**。
      * 但这个变量跟通常意义上的变量又有所不同，它的值可以变，但是我们无法修改它。
      * 因为表达式的值存储在一个匿名对象中，类似字面值一样，我们无法访问。
      * 但是它又和字面值不同，字面值一定是一个常量，它不会变。但是表达式的值会在运行时变化。
    * **所以又有了常量表达式，它就相当于一个常量，可以当做常量用**。
      * 常量表达式是仅仅包含常量的表达式.这种表达式在编译时求值，而不在运行时求值。

## 3.2 操作数和操作符

> 表达式的类型主要取决于操作符的类型

#### 3.2.1 操作数

* 所有有值的键都可以作为操作数
* 所以操作数可以是表达式，数值字面值，字符字面值，数值变量，函数调用等等。

#### 3.2.2 操作符

##### 1. 算术运算符

* 算术表达式

  * 算术运算符连接的是算术表达式，**值是实际的结果。**,值得类型是表达式类型转换的公共类型。

* 表

  * | Operator       | Meaning              |
    | -------------- | -------------------- |
    | +, -, * , /, % | 加减乘除，取摸(求余) |

    * 整数除法会截断小数部分。
    * 取余只能用于整型，不能用于浮点型。
      * 当有负整数形式时，余数符号取决于具体硬件。

##### 2. 自增自减运算符

* 表达式的值
  * 前置是变量自增自减后的值，后置是变量自增自减前的值

* 左值
  * 自增自减只能用于变量，不能用于表达式。
  * 因为变量是左值，我们可以修改，表达式值我们无法直接修改，因为其存储对象是匿名的。
* ++， --
  * 自增1，自减1

##### 3. 位运算符

* 表达式的值

  * 实际计算后的结果

* 操作数限制

  * 只能作用于整型操作数

* 表

  * | Operator    | Meaning                                                      |
    | ----------- | ------------------------------------------------------------ |
    | &, \|, ~, ^ | 按位与或非,异或                                              |
    | <<, >>      | 左移右移。左移补0，右移取决于机器，补0逻辑右移，补符号位算术右移。 |

##### 4.关系和逻辑运算符

* 关系表达式

  * 关系和逻辑运算符连接的是逻辑表达式，**值是0或1**，取决于关系的真或假。

* 表

  * | Operator                     | Meaning                                      |
    | ---------------------------- | -------------------------------------------- |
    | >,    >=,   <,   <=,  ==, != | 大于，大于等于，小于，小于等于，等于，不等于 |
    | &&, \|\| , !                 | 与或非                                       |

    * 二元逻辑运算符 &&和||都规定了从左到右的求值顺序并且是短路求值。
      * &&前面为真后面才继续求值，||前面为假后面才继续求值。

##### 5. 赋值运算符

* 赋值表达式

  * 有赋值运算符的是赋值表达式，表达式的值是赋值完成后左操作数的值，类型是左操作数的类型。

* 表

  * | Operator          | Meaning                                                      |
    | ----------------- | ------------------------------------------------------------ |
    | =                 |                                                              |
    | +=, -=, *=, /=,%= | a+=2,以前老是翻译为a=a+2,其实不用翻译，直接理解为a增加2就行了 |
    | <<=,>>=,&=,\|=,^= |                                                              |

##### 6. 条件运算符

* 形式
  * expr1?expr2:expr3
    * expr1为真，执行expr2,为假执行expr3

* 条件表达式
  * 条件运算符参与的是条件表达式，值可能是expr2或expr3的类型。
  * 但是值的类型跟算术表达式差不多，取决于条件表达式整体的转换的公共类型，跟expr1真假无关。
    * 例如expr2值为int型，expr3值为double型，那么最终条件表达式的值类型为double型，与真假无关。

##### 7. 函数调用运算符

#### 3.2.3 运算符优先级、结合性别与求值顺序

##### 1. 优先级和结合性

* 优先级规定了运算符优先级不同时的计算顺序

* 结合性规定了运算符优先级相同时的计算顺序

  * | Opeator                   | Meaning                                    | 结合性                 |
    | ------------------------- | ------------------------------------------ | ---------------------- |
    | ()    []   ->   .         | 函数调用，访问结构成员                     | 左结合(即从左到右顺序) |
    | !   ~  ++  --  +  -  *  & | 逻辑非，按位取反，正负号，指针访问，取地址 | **右结合**             |
    | *   /      %              | 乘除取余                                   | 左结合                 |
    | +  -                      | 加减                                       | 左结合                 |
    | <<  >>                    | 左右移                                     | 左结合                 |
    | <   <=  > >=              | 小于，小于等于                             | 左结合                 |
    | == !=                     | 等于，不等于                               | 左结合                 |
    | &                         | 按位与                                     | 左结合                 |
    | ^                         | 按位异或                                   | 左结合                 |
    | \|                        | 按位或                                     | 左结合                 |
    | &&                        | 逻辑与                                     | 左结合                 |
    | \|\|                      | 逻辑或                                     | 左结合                 |
    | ?:                        | 条件运算                                   | **右结合**             |
    | =  +=  -=  *=   /= %= &=  | 复合赋值                                   | **右结合**             |
    | ^= \|= <<= >>=            | 复合赋值                                   | 左结合                 |
    | ,                         | 逗号运算符                                 | 左结合                 |

##### 2. 求值顺序

* 二元运算符两边操作数为普通变量，不存在求值问题，直接计算即可。
* 当两边操作数为表达式，那么计算之前就要先求出表达式的值。
  * C语言大部分二元运算符没有规定求值顺序，有可能先求左表达式或右表达式。
  * &&， || 规定从左到右求值，并且&&左边值为真才继续求值，||左边值为假才继续求值。
  * ，运算符从左到右依次求值。
* 应该尽量避免计算结果与求值顺序有关。

## 3.3 类型转换

#### 3.3.1 概念

* 数值类型转换

  * 最常见的类型转换就是数值类型之间的转换。

  * 本质是现在的数值计算都是2的补码表示形式，所以即使表示同一个值，数值类型不同，值的表现形式也不同，所以计算不同类型数时需要首先同意转换为一种数据类型。

* 原变量不变

  * 原变量是不能修改的，所以如何完成数值类型转换，那么就是创建类型为变量要转为的类型的匿名变量并初始化为待转变量的值，然后利用这个匿名对象计算，计算完成后销毁该对象。

  * **切记转换这个词比较有迷惑性，变量是不会变的，所谓转换其实是新建一个和变量值相同但是类型不同的匿名对象完成计算然后销毁**

    * ```c
      int a =10;  long b = 100;
      a+b;
      //a+b这是一个表达式，求值时,需要将a转为long类型，说是这么说的，但是a的值是不会变得。
      //我们都知道，表达式都是有一个值的，这个值得有地方保存，所以一定有一个保存表达式值的匿名对象
      //如果只需要转换一个类型，那么我们就可以利用这个匿名对象，创建一个long匿名对象保存a的值，然后把b加进来就行了。。
      //如果有大于1个的需要类型转换的变量，那么还要创建更多的匿名对象
      ```

#### 3.3.2 分类

##### 1. 自动(隐式)类型转换

* 定义
  * 很多情况下C语言进行自动(隐式)类型转换。
  * 转换的原则一般是"小"转"大"，尽量不损失数值精度。
    * 算术表达式转换一般不损失精度
    * 赋值表达式转换则取决于具体转换
* 分类
  * 算术运算表达式
    * 二元运算符两边操作数要转为同一类型。
    * 转换规则
      * 详细版
        * 见《c语言程序设计第二版》173页附录A.6
      * 如果表达式中不涉及无符号整数，那么用下列规则即可
        * 一个操作数为long double, 另一个也转long double
        * 一个操作数double，另一个也转double
        * 一个操作数为float，另一个也转float
        * char和short操作数都转int(本质是因为最少都是为32位设计的加减乘除)
        * 一个操作数为long，另一个转long
        * 如果一个表达式涉及多种类型参与，那么首先会转换为一个公共类型进行运算。表达式的值的类型将会是这个公共类型。
  * 赋值
    * 赋值号右边表达式的值要转为左边的类型。
    * 赋值表达式，函数参数传递等凡是需要赋值的地方都会隐式类型转换。

##### 2. 强制类型转换

* 定义

  * 强制类型转换，程序员手动强制转换类型

* 用法

  * (类型名) 表达式

    * ```c
      (double)(2+3);
      char a='b';
      (int)a;
      ```

  * 切记类型转换的本质不是修改原来的变量或者表达式，而是新建一个同值的符合类型的匿名对象，然后用完后销毁。

# 4 流程控制

> flow control

### 1.4.1 条件(condition)

* 条件部分可以是任意表达式
* 判断流程
  * 执行表达式
  * 得到表达式的值
  * 根据表达式值进行条件判断
    * 0表示假
    * 非0表示真

# 5. 语句与块

### 1.语句

* 每个分号标识一个语句

### 2. 块

* 一对花括号标识一个块,语法上等价于一条语句。

# 6 预处理机制

