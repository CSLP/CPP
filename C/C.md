# C 本体

> 所谓本体就是语言原生支持的操作，无需借助任何外部程序，包括标准库的程序

## 引言

* 本体不支持
  * 复合数据结构直接处理
    * C语言不提供直接处理诸如字符串、集合、列表或数据等复合对象的操作。虽然可以将整个结构作为一个单元进行拷贝，但C语言没有处理整个数组或字符串的操作。
  * 存储管理
    * 除了由函数的局部变量提供的静态定义和堆栈外，C语言没有定义任何存储器分配工具，也不提供堆和无用内存回收工具。
  * 输入输出
    * C语言本身没有提供IO功能，没有READ或WRITE语句，也没有内置的文件访问方法。所有这些高层的机制必须由显式调用的函数提供。
  * 并行
    * C语言只提供简单的单线程控制流，即测试、循环、分组和子程序，它不提供多道程序设计、并行操作、同步和协同例程。
* 语言学家？
  * 有关编程语言的官方标准，即最全最准最细的语言介绍，是给编译器实现者看的，不是给普通程序员看的，所以我们没必要了解所有细节，大概知道整个知识树，用什么细节钻研什么细节就行了。
  * 所以笔记没必要奢求一次性把所有相关只是内容记下来，只需第一遍填充整体的框架，然后以后一遍一遍根据实际应用填充细节即可。

# 1. 底层背景

> 一些有关计算机底层的概念

### 1.1 内存抽象

* 字节数组
  * 对于程序而言，内存就是一个巨大的字节数组，下标是从0x0000000000000000(64位机器)开始的地址，值是8bit的位pattern。
* 键值对
  * 内存就是一个数组，换言之就是键值对，键是下标，值是值。
  * **所以底层对于内存的访问永远是靠键，即地址。**
  * 语言提供的抽象也是键值对，并且通过键来使用值
    * 只不过语言提供的所谓<变量名-值>、<引用-值>、<指针-值>等键值对
    * 其键的底层本质都是地址访问，只不过编译器隐藏了这一点然后给我们提供抽象罢了。
* 对象的地址
  * 因为内存都是一个字节对应一个地址。
  * **所以所谓数据结构的地址就是数据结构所占连续存储空间的第一个字节的地址**

# 2. 对象

> 对象或者变量或者说数据结构就是语言提供给我们的**可以读写的一块内存的抽象**，仅此而已。

## 2.1 关于对象

* 对象是一个命名的存储区域

* 对象有时也称为变量
* 对象分为对象名(标识符)和对象本体两部分。
* 对对象的解释依赖于两个主要属性:**存储类**和**类型**

### 2.1.1 标识符

#### 1. 名字

* 名字
  * 标识符也称为名字，是程序员自定义的对象名，可以指代多种实体：
    * 函数、结构标记、联合和枚举标记
    * 结构成员或联合成员
    * 枚举常量
    * 自定义类型名
    * 标号和对象等

* 命名要求

  * 大小写敏感
  * 下划线或字母开头
  * 下划线开头的标识符多用于标准库，所以自己尽量不要用

  

  * 作用域和连接

  * 名字具有一个作用域和一个连接。
    * 作用域即程序中可以访问此名字的区域
    * 连接决定另一作用域中的同一个名字是否指向同一个对象。
  * 作用域
    * 外部对象(变量)
    * 局部对象(变量)

#### 2. 作用域和连接

> 名字具有一个作用域和一个连接。

##### 2.0 背景

* 一个程序所有单元不必同时进行编译。源文件可保存在若干个文件中，每个文件中可以包含多个翻译单元，预先编译过的例程可以从库中进行加载。程序中函数间的通信可以通过调用和操作外部数据来实现。
* 因此，我们需要考虑两种类型的作用域
  * 标识符的词法作用域，它是体现标识符特性的程序文本区域(就是名字直接可用的区域)
  * 具有外部连接的对象和函数相关的作用域，它决定各个单独编译的翻译单元中标识符之间的连接。

##### 2.1 词法作用域

> 作用域即程序中可以访问此名字的区域

* 命名空间
  * 标识符可以在若干个名字空间中使用而互不影响。
  * 如果位于不同的名字空间中，即使是在同一作用域内，相同的标识符也可用于不同的目的。
* 作用域范围
  * 在外部声明中，对象或函数标识符的词法作用域从起声明结束的位置开始，到所在翻译单元结束为止。
  * 函数定义中形式参数的作用域从定义函数的程序块开始处开始，并贯穿整个函数
  * 函数声明中形式参数的作用域到声明符的末尾结束。
  * 程序块头部声明的标识符的作用域是其所在的整个程序块。
  * 标号的作用域是其所在的函数。
  * 结构标记、联合标记、枚举标记或枚举常量的作用域从其出现在类型说明符中开始，到翻译单元结束为止(对外部声明而言)或到程序块结束为止(对函数内部声明而言);
  * 如果某一表示符显式的在程序块头部中声明，则该程序块外部中次标识符的任何声明都将被挂起，知道程序块结束在恢复其作用(简而言之就是存在块内外同名队形啊，那么块内使用用内部的)

##### 2.2 连接

* 在翻译单元中，具有内部连接的同一对象或函数标识符的所有声明都引用同一实体，并且，该对象或函数对这个翻译单元来说是唯一的。
* 具有外部连接的同一对象或函数标识符的所有声明也引用同一实体，并且该对象或函数是被整个程序中共享的。
* 程序块内的一个标识符如果不包含extern声明，那么表示标识符没有连接，在函数中唯一。
* eg
  * 连接主要是外部声明有这个说法
  * 不加static的外部声明或函数具有文件作用域和外部连接，外部连接意味着在其他文件也可用，但要extern声明一下
  * 加static的外部声明或函数具有文件作用域和内部连接，内部连接意味着在其他文件无法引用该实体，加extern也没用。

### 2.1.2 存储类

* 概念

  * 存储类决定了对象的存储区域的生存期
  * 生存期指变量所在内存块没被释放的这段时间

* 分类

  > 声明对象时使用的一些关键字和声明的上下文共同决定了对象的存储类

  * 自动存储类(automatic)
    * 省略或者使用auto限定符的局部对象都是自动存储类对象。
    * 自动存储类对象函数执行时创建，函数执行完毕后销毁
  * 静态存储类(static)
    * 所有外部对象默认都是静态存储类
    * 加static限定的局部对象是静态存储类。
    * 静态存储类对象编译时创建，程序结束时释放。

### 2.1.3 类型

> 类型决定了标识对象中值的含义，即编译器如何解释二进制串。

#### 1. 基本类型(算术类型)

* 整型类型(integral type)
  * int
  * short int
  * long int
  * char
  * 枚举
* 浮点数类型(floating type)
  * float
  * double
  * long double

#### 2. 派生类型

> 以下构造派生对象的方法可以递归使用

* 给定类型对象的数组
* 返回给定类型的函数
* 指向给定类型的指针
* 包含一系列不同类型对象的结构
* 可以包含多个不同类型对象中任意一个对象的联合。



#### 3. 类型相关

> C语言强类型检查。

##### 1. 类型限定符

* 概念

  * 对象的类型可以通过附加的限定符进行限定。
  * 限定符既不影响对象取值的范围，也不影响其算术属性。

* 分类

  * const
    * 表示此对象的值不可以修改

  * volatile
    * 表明此对象具有与优化相关的特殊属性

##### 2. sizeof

* 概念
  * 第一眼看上去像一个标准库函数，其实它就是语言自带的一个运算符，和+,-等运算符没有任何区别。
  * 它是由C语言提供的一个编译时(compile-time)一元运算符，可以用来计算任一对象的长度(单位为B)。
* 使用
  * sizeof 实际对象
  * sizeof(类型名)
    * 返回一个定义在<stddef.h>中的size_t无符号整型值，表示对象所占存储空间字节数。
    * 实际对象可以是任意变量对象，C内置的或自定义的
    * 类型名可以是任意类型名，系统内置的或自定义的

##### 3. typedef

* 概念

  * 根据已有类型名声明新的类型名
  * typedef不创建新类型，只是给已有的类型创建一个别名
    * 类似#define,只不过#define由预处理器负责替换，typedef由编译器负责替换，功能更强。

* 形式

  > 其实跟变量定义差不多，只不过是变量名换成了类型名，然后最前面+typedef关键字

  * ```c
    typedef int INT;
    typedef int *Ip; //定义Ip为int指针类型的别名
    typedef char *String;
    typedef struct point
    {int x; int y}  recPoint;  //定义recPoint为point类型的别名
    typedef int (*funcP)(char*, char*) //定义funcP为 int (char*,char*)函数类型的指针的别名
    ```

* 作用

  * 使声明定义更简洁，为程序提供更好的说明性。总之就是加强可读性。

    * 尤其是涉及函数类型，简洁的一批

  * 使程序参数化，提高程序的可移植性。

    * 例如已存在类型是机器相关的，那么就可以给这个类型定义别名，程序中使用这个别名，移植的时候只需重新定义类型就行了。

    * ```c
      //16位机器int是16位的，long是32位的，32位机器int是32位的，如果我们想在程序中使用int，并且希望跨平台时这个int都是32位
      //那么程序中直接使用int是不行的，16位机器分配16位空间，可以这样
      //16位机器这么定义
      typedef long int32;
      //32位机器这么定义
      typedef int  int32;
      这样程序文本中凡是使用int的地方使用int32,这样就实现了跨平台的目的。
      事实上标准库提供的什么size_t，int32之类的都是这么来的。
      ```

##### 4. 类型转换

* 总体原则是小转大，不损失精度，可以强制类型转换
* 如果是算术表达式，那么所有操作数会首先转换为一个公共类型，结果的值的类型就是这个公共类型
* 详见C程序设计语言第二版参考手册A.6转换部分。

### 2.1.4 对象和左值

* 对象是一个命名的存储区域，左值(lvalue)是引用某个对象的表达式
  * 常见的左值
    * 普通的算术整型变量
    * *指针引用的对象
  * 个人理解
    * 左值就是可以自己合法修改的一个对象，可以作为赋值符号的左操作数.
    * 一个例外是const修饰的变量是左值，但是无法修改。

## 2.2 对象声明、定义、初始化

> declaration , define，initialization

### 2.2.1.声明

* 意义
  * 声明用于说明每个标识符的含义，而并不需要为每个标识符预留存储空间。
* 注
  * 变量可以多次声明

#### 1. 外部声明

* 意义

  * 提供给C编译器处理的输入单元称为翻译单元(通常一个源文件是一个翻译单元)。
  * 它由一个外部声明序列组成，这些外部声明可以使声明，也可以是函数定义(定义是特殊的声明罢了).

* 形式

  * ```
    翻译单元:
    	外部声明
    	翻译单元 外部声明
    外部声明:
    	函数定义
    	声明
    ```

  * 外部声明的作用域一直持续到所在翻译单元的末尾。


### 2.2.2 定义

#### 1. 意义

* 意义
  * 定义就是给变量预留存储空间的声明
  
* 注
  * 准确来讲，定义仅仅是预留存储空间的声明，所以不包括构建和初始化存储空间内容，构建和初始化严格来讲是一个独立的阶段，定义之后进行的阶段。
    * 但是程序员会显示初始化，如果没有，那么编译器也会默认初始化，所以也可以说定义就包含了构建和初始化过程。
    * 所以可以理解为定义就是:声明变量、分配内存、构造变量并初始化
  * 可以理解为生成了一个键值对
  * 定义就一定包含了声明。
  * 不可以重定义(当变量还处在生存期)

#### 2. **形式**

> 定义就是预留存储空间的声明，所以下列用声明一词，大部分都是定义声明，少部分是纯粹的声明

##### 2.1 基本形式

* ```c
  [存储类说明符] 类型说明符 [类型限定符] 标识符[=初值]
  ```


##### 2.2 存储类说明符

* 关键字

  * auto
  * register
  * static
  * extern
  * typedef

* 说明

  > 以下严格区分声明，定义，定义代表分配存储空间

  * auto,register
    * **定义**变量为自动存储类变量，register暗示该变量频繁访问，希望将其放在寄存器。
  * static
    * **定义**变量为静态存储类。
    * 对于局部变量，定义静态存储类变量，对于外部变量，主要作用是限制对象为文件作用域
  * extern
    * 声明对象，表示对象定义在其他地方。
  * typedef
    * 不算存储类说明符，放在这里为了方便说明，它就是声明一个类型别名。
  * 省略
    * 局部变量默认auto，外部变量默认静态存储且具有外部连接

##### 2.3 类型说明符

* 基本类型类型说明符

  * 形式
    * void,char,short,int,long,float,double,long double
    * signed, unsigend
  * 说明
    * signed,unsigned(搭配在int,long等算术类型前面控制无符号或有符号)
    * 一个声明中最多只能有一个类型说明符

* 派生类型类型说明符

  * 形式

    * 结构或联合说明符
    * 枚举说明符
    * 类型定义名(typedef定义的别名)
    * 指针说明符
    * 函数说明符
    * 数组说明符

  * 详解

    * 结构或联合说明符

      * ```c
        struct/union  结构标记/联合标记{body} ; 
        struct/union  结构标记/联合标记{body}  标识符；
        struct/union  结构标记/联合标记    标识符；
        ```

      * 定义了结构标记和联合标记之后就可以直接将其当做类型说明符使用了。

    * 枚举

      * ```c
        enum 枚举标记 { 标识符[=初值] };
        enum 枚举标记 { 标识符[=初值] } 标识符；
        enum 枚举标记   标识符；
        ```

      * 定义了枚举标记之后就可以直接将其当做类型说明符使用了。

    * typedef

      * typedef  已存在类型名    别名

    * 数组说明符

      * 元素类型  标识符[N]

    * 函数说明符

      * 返回值类型  标识符(参数表)

    * 指针说明符

      * 基本类型元素指针

        * 基本类型 * 标识符

      * 结构，联合，枚举指针

        * ```c
          struct/union/enum 标记{body} * 标识符；
          struct/union/enum 标记 * 标识符；
          ```

      * 数组指针

        * 元素类型 （* 标识符）[N]

      * 函数指针

        * 函数返回值类型   (* 标识符)(函数参数列表)

##### 2.4 类型限定符

* 保留字

  * const
  * volatile

* 说明

  * const

    * 限定变量为常量，必须显式初始化。
    * 一般const出现在紧邻标识符的前面限定变量，且只出现一次，只有一个特例:
    * ```int * const pt;     const int * pt;   const int * const pt```
      * 分别为:常量指针；指向常量的指针；指向常量的常量指针；
      * 意义为:该指针值不能修改，即初始化后不能修改指针指向；不能通过该指针修改指向的对象；该指针不能修改指向且不能通过该指针修改指向的对象。

  * volatile

    >  [ˈvɑːlətl] a.易挥发的，不稳定的

    * volatile对象没有与实现无关的语义，即用于强制某个实现屏蔽可能的优化。

##### 2.4 标识符

* 数字字母下划线组成
* 开头不能用数字，也最好不要用下划线，因为很多库函数下划线开头。
* 语言保留字不能用，对应于保留字，我们一般称自定义的名字为标识符
* 常量用全大写加下划线。

### 2.2.3 初始化

* 意义

  * 定义变量的时候会执行变量初始化

* 形式

  * 标识符=初值

  * 初值紧跟在赋值运算符之后，它可以是一个表达式，也可以是嵌套在花括号中的初值序列

  * ```
    初值:
    	表达式
    	{初值表}
    	{初值表,}
    初值表:
    	初值
    	初值表，初值

* 初始化类型
  * 默认初始化
    * 对于局部变量而言就是随机值
    * 对于外部变量和静态变量就是0.
    * 对于结构，类等复杂变量而言就是构造函数设定的默认值。
  * 赋值初始化
    * 初始化表达式
      * 常量表达式
        * 外部变量、静态变量、局部变量
      * 非常量表达式
        * 局部变量
  
* 几种类型的初值形式

  * 静态存储对象默认初始化为0，自动对象默认初始化未定义值。
  * 指针或算数类型的初值是单个表达式。
  * 结构初值: 同类型表达式；花括号括起来的按其成员次序排列的初值表。
  * 数组初值: 花括号初值表
  * 字符串数组:花括号初值表或字符串字面值
  * 联合初值:同类型表达式；联合第一个成员的初值

* 聚集

  * 聚集是特殊的结构或数组。

    * 如果结构包含结构成员，那么是一个聚集。
    * 如果是大于一维的数组，即数组的元素还是一个数组，那么该数组是一个聚集。

  * 聚集初始化递归使用初始化规则

    * ```c
      int [3][2]={{1,2},{1,3}};
      ```


### 1.1.6 生存期和作用


#### 2. 作用域

> 就是变量名即标识符这个键的作用范围，就是程序中可以使用该名字的部分。
>
> 外部变量和函数都为外部对象，所以名字作用域基本一模一样。

##### 2.1 外部变量

* 普通外部变量

  * 全局作用域，所有源文件都可使用

    * 定义全局变量的文件，作用域为定义或声明始到文件尾部
    
    * 其他文件，需要显式extern声明后使用，作用域声明始到文件尾部。
    
      * ```c
        //file1.c
        int test;
        int main()
        {}
        //file2.c
        extern int test;
        int main()
        {test=10;}
        ```
  
* 静态外部变量

  * 文件作用域
    * 仅限定义文件使用，作用域从定义或声明始到文件尾。
    * 其他文件不可用，即使extern显式声明也没用。

##### 2.2 函数名

* 普通函数
  * 全局作用域，所有源文件都可用
    * 定义全局变量的文件，作用域为定义或声明始到文件尾部
    * 其他文件，需要有函数原型才能使用，作用域从函数原型声明到文件尾。

* 静态函数(加了static限定的函数)
  * 文件作用域
    * 仅限定义文件使用，作用域从定义或声明始到文件尾。
    * 其他文件不可用，即使声明函数原型也没用


##### 2.3 局部变量

* 不论普通或静态局部变量，都是块作用域，块儿内使用

## 2.3 常见对象辨析

### 2.3.1 变量、常量

#### 1. 变量

* 可读写
  * 程序层面可以读写的内存抽象就是变量


* 运行时
  * **变量的值在运行时确定**


#### 2. 常量

##### 2.1 定义

* 只读

  * 硬件上一块内存总是可以读写的，所以其抽象叫做变量

  * 出于软件需要，有时要限制变量的修改，限制变量为只读，那么这个只读的“变量”就是常量
    * 限制方案有两种
      * 编译器提供的限制，数据存储在匿名对象中，我们无法修改，所以是常量
      * 程序员通过const, #define等语法，定义了有标识符的常量。

* 编译时
  * **常量的值在编译时确定**

#####  2.2 分类

###### 2.2.1 字面值常量

* 定义

  * 一种特殊的“变量”，它的键十分特殊，特殊在两点
    * 它的键就是它的值的，所以叫字面值。
    * 我们只能读存储字面值的这块内存，而无法修改，因为它是匿名的。

* 分类

  * 整型常量
    * 形式
      * 不加引号，没有小数点或者e,E
      * 支持十进制，八进制(0开头)，十六进制(0x开头，大小写都行)
      * uU后缀表示无符号，lL表示长整型
    * 类型
      * 每个变量都有类型，整型常量是特殊的变量，也有类型
      * 类型取决于它的形式、值和后缀
        * 形式指用什么进制表示的
        * 编译器会自动选择合适的类型存储常量

  * 字符常量

    * 形式

      * 单引号括起来的一个或多个字符构成的序列
      * 单字符常量的值是执行时机器字符集中此字符对应的数值
      * 多个字符构成转义序列，值由具体实现定义。

    * 转义序列

      * 转义序列可以方便的输入不可显示字符和键盘无法直接输入的字符。

      * | 序列 | 意义                  | 序列 | 意义             |
        | ---- | --------------------- | ---- | ---------------- |
        | \n   | 换行符(NL(LF))        | \\   | 反斜杠字符       |
        | \t   | 横制表(HT)            | \?   | 问号字符         |
        | \v   | 纵制表(VT)            | \\"  | 双引号           |
        | \b   | 回退符(BS)            | \\'  | 单引号           |
        | \r   | 回车符(CR)            | \ooo | 八进制数对应字符 |
        | \f   | 换页符(FF(form feed)) | \xhh | 16进制数对应字符 |
        | \a   | 响铃符(BEL(bell))     |      |                  |

    * 类型

      * 一个字节的char类型
      * 多字节的wchar_t类型，常量以L开头(eg: L'x')

  * 浮点常量

    * 形式
      * 整数部分+小数点+小数部分
      * 整数部分+e,E+带符号整数表示的指数部分
      * 后缀f,F,l,L
    * 类型
      * 后缀f,F表示 float类型
      * l,L long double类型
      * 省略表示double类型

  * 字符串常量

    > 字符串字面值  string literal

    * 形式
      * 双引号括起来的一个字符序列，可以包含转义符
    * 类型
      * 以'\\0'结尾的字符数组

###### 2.2.2 符号常量

* 定义

  * 字面值常量没有名字，或者说名字就是字面值，不好用。
  * 符号常量就是程序员定义的具有标识符也就是名字的常量。
  * **本质就是给上面的不同类型的字面值常量取个名字方便使用**。
    * 正因为如此，因为字面值没有具有逻辑意义的名字，所以要使用具有明显逻辑意义的常量时，
    * 最好定义一个符号常量使用，而不是随处乱使用值相同的字面值常量。

* 分类

  * const 常量

    > 可以是以下类型

    * 整型常量
    * 字符常量
    * 浮点常量
    * 字符串常量

  * #define常量

    * 整型常量
    * 字符常量
    * 浮点常量
    * 字符串常量

  * 枚举常量

    * 整型常量

### 2.3.2 外部变量、局部变量

#### 1. 静态变量

* 定义
  * static限定定义的变量是静态变量
  * 在编译时创建并分配存储空间，只能定义初始化一次，程序结束后销毁。
    * 创建时默认初始化为0，赋值初始化的话必须用常量表达式初始化
* 分类
  * static限定的外部变量是静态外部变量
  * static限定的局部变量是静态局部变量

#### 1. 外部对象(变量)

* 定义

  * 定义在所有函数之外，且在全局范围内即所有源文件中只能定义初始化一次，由编译程序分配存储单元
    * 定义时默认初始化为0，赋值初始化的话必须用常量表达式初始化。

  * 定义在所有函数之外，所以也叫外部变量，也可以说外部变量跟函数是同级的。

* 分类

  > 区别只在于作用域

  * 具有外部连接的外部变量
    * 外部连接
      * 省略存储类限定符或extern声明的外部变量具有外部连接
    * 全局作用域
      * 定义所在文件
        * 作用域从定义位置始到文件尾部
      * 其他文件
        * 需要显式extern声明，作用域从声明位置始到文件结尾。
        * 所以严格来说，应该是文件作用域，因为在其他文件使用需要external声明，准确来讲是具有文件作用域和外部连接。
  * 具有内部连接的外部变量
    * 内部连接
      * static限定的外部变量，将外部变量声明为文件翻译单元的局部对象，具有内部连接。
    * 文件作用域
      * 从定义位置到文件尾部。
      * 其他文件即使显式extern声明了也不能用，准确的来讲是具有文件作用域和内部连接，所以其他文件extern声明了也不能用。

#### 2. 局部对象(变量)

* 定义
  * 函数内定义的变量叫局部变量
  * 函数的形参也是局部变量，把他看做局部变量就行了，就这么简单。


* 分类

  > 区别只在于生存期

  * 动态存储类的局部变量
    * 省略或auto限定的局部变量
    * 动态存储类局部变量在函数执行时创建，执行完毕后销毁，所以理论上函数调用多少次，那么局部变量就会定义初始化多少次。

  * 静态存储类局部变量
    * static限定的局部变量
    * 静态局部变量编译时创建初始化一次，无论函数调用与否，静态局部变量一直存在到程序结束。

* 小误区

  * ```c
    for(int i=1; i<20; i++)
    {
      int p=10;
    }
    //以前有个愚蠢的想法，这个p是不是每次循环都要重新创建。。
    //显然不会，只会函数调用时第一次遇到后他才是个定义语句，创建，之后每次循环不过就是执行到第4行然后又跳回到第二行执行，编译器知道这是for循环之内，再次遇到这个语句，不会当做定义语句，所以不会在创建一次了
    ```



# 3. 对象类型

## 3.1 算术类型变量

#### 1. 类型和范围

* 整型

  * | Type           | C语言要求至少 | 32位硬件典型实现 | 64位硬件典型实现 |
    | -------------- | ------------- | ---------------- | ---------------- |
    | char           | 8bit          | 8bit             | 8bit             |
    | signed char    | 8             | 8                | 8                |
    | unsigned char  | 8             | 8                | 8                |
    | short          | 16            | 16               | 16               |
    | unsigned short | 16            | 16               | 16               |
    | int            | 16            | 32               | 32               |
    | unsigned int   | 16            | 32               | 32               |
    | long           | 32            | 32               | 64               |
    | unsigned long  | 32            | 32               | 64               |

    * C语言要求short和int最少16位，long最少32位，short不能长于int，int不能长于long
    * short和long是 short int 和long int的简写。称为短整型和长整型
    * n位无符号类型整数运算时遵循模2的n次方的规则，所以永远不会溢出
    * 具体实现由编译器根据对应硬件平台决定。
    
  * 整型字面值
  
    * 支持十进制普通形式、科学计数法形式，八进制，十六进制  
  
      * 八进制0开头，012，十六进制0x开头(大小写均可)
  
      * ```c
        int a=10, b=012,c=0xff,d=0xFF;
        long nb=2e10;  //2e10表示2乘以10的10次方。
        ```
  
      * 
  
    * 整型字面值的匿名存储对象默认是int类型，如果超范围了，那么就用long类型，也可以手动指定
  
      * l和L结尾，手动指定匿名存储对象为有符号long类型，用8B存储
  
      * u和U结尾，指定为无符号类型
  
        * ```c
          long x=123l,y=133L;
          long x=233ul,y=23u;
          ```
  
  * 字符变量
  
    * 字符变量是比较特殊的一种整型变量，普通整型变量按照2的补码解释，字符变量按照ASCII解释。
  
      * 这个解释仅适用于输入输出函数
      * 表达式中的字符变量则完全按照1B的小整型参与计算
    
    * ASCII只定义了7位，所以字符变量的范围限定为0x00~0x7F。
    
    * 字符字面值
    
      * 键盘可直接输入的那么包在单引号内直接输入即可。
    
      * 无法直接输入或者无法显示的字符，可以用转义序列表示。
    
      * 常用转义序列
    
        * | 序列  | 字符           | 序列        | 字符                                            |
          | ----- | -------------- | ----------- | ----------------------------------------------- |
          | '\\n' | 换行           | '\\r'       | 回车                                            |
          | '\\0' | 空字符null     | '\\ooo'     | ASCII中八进制数对应的字符                       |
          | '\\t' | 制表符         | '\\xhh'     | 16进制数对应的字符(16进制大小写都行\\x1F,\\x1f) |
          | '\\?' | 问号也要转义。 | '\\'','\\"' | 单双引号转义                                    |
  
* 浮点型

  * | Type        | 32位硬件典型实现 | 64位硬件典型实现 |
    | ----------- | ---------------- | ---------------- |
    | float       | 4B               | 4B               |
    | double      | 8B               | 8B               |
    | long double | 8B               | 16B              |

    * float 单精度浮点数，double双精度浮点数,long double 多精度
    * 具体范围取决于机器。
    
  * 浮点数字面值
  
    * 支持小数点形式和科学计数法形式
  
      * ```c
        double a=0.01   <==>   double a=1e-2   //(1乘以10的负二次方)
        ```
  
    * 默认字面值匿名存储对象类型为double
  
      * 后缀f和F指定为float型
      * 后缀l或L指定为long double类型
        * 如果字面值不是小数，加后缀l，L表示long 型整数，如果是小数表示long double型浮点数。
  
* 枚举

  > 本质是定义了一堆枚举符+可以用枚举符赋值的枚举变量

  * 定义和声明
  
    * ```c
      enum colors {red,blue,white};
      enum colors {red=2, blue=4,white};
      ```
  
      * 声明了枚举标记colors和3个枚举常量red,blue,white
      * 枚举符表中标识符声明为int型常量，如果其中不包括=的枚举符，则相应常量从0开始依次递增。
      * 如果包括=，那么不包括等号的枚举符的值从最近的等号开始依次递增。
      * 枚举符标识符不可以重名，但是值可以相同。
  
    * ```c
      enum colors {read,blue,white} c1;
      enum colors c2;
      ```
  
      * 定义枚举标记和三个枚举符同时定义了两个枚举变量。
  
      * 定义枚举标记后可以直接用枚举标记定义枚举变量。
  
      * 枚举变量可以用枚举符赋值，所以该枚举符所有赋值的地方都用枚举符赋值而不是int常量赋值，这样逻辑上十分清晰，逻辑上限定枚举变量的取值范围只能是列出的枚举符。防止意外赋值。
  
      * ```c
        enum colors {red,blue,white} c1;
        c1=white;
        if(c1==white)
            ;
        ```

#### 2. 声明

* extern int x;
  * 只有外部变量声明是单纯的声明，不会定义。
  * 其他的局部变量声明就是定义，定义就是声明。

#### 3. 定义

* [限定符]  整型类型  变量名；

* 浮点类型 变量名；

  * ```c
    signed int a;	
    unsigned int a,b;
    int a=10;
    int a=10,b=20;
    int a=b;
    
    //构建没有初始化，值为随机值
    char var1
    //构建并以字面值初始化，转义字符斜杠用来表示无法输入的或无法显示的字符字面值
    char var1='a',var2='\n',var3='\"', var4='\0',var5='\123'
    //构建并以字符变量初始化。
    char var1='a'
    char var2=var1
    ```
  
  * 限定符signed和unsigned用于整型变量，表示有符号或无符号，省略限定符那么表示有符号，char除外，char取决于机器。

## 3.2 指针

##### 1. 解析

* 变量
  * 指针是一个变量
  * 这个变量的值只能是地址值或者说C语言只会把指针的值解释为地址。
  * 指针指向某个变量代表指针存储的地址是该变量的地址。
  * **指针只能存储地址值，所以指针的大小是恒定的**，地址多少位代表指针大小就是多少位
    * 所以32位机器指针大小32位，64位指针大小64位。

##### 2. 声明和定义

> 指针是简单的变量，没有只声明而不定义的形式，往往都是定义的时候就声明了，所以这里一起说

* 形式

  * 类型名   (* 变量名)

    * ```c
      int *p;             //指向int型变量的指针
      double *p;		    //指向double型变量的指针
      char * *p;			//指向字符指针或者说字符串的指针
      int (*p) [12];	    //指向一个一维数组，元素为int型，个数为12
      int (*p)(int,int)   //指向一个返回值为int，参数为两个int的函数
      ```

    * 定义并默认初始化了一个指针，类型名表示指针类型，或者更准确的说表示指针所指对象的类型。

    * **括号括起来是为了强调，*加变量名是一体的，表示该名字是一个指针，然后其余所有部分都是表示指针类型。**

* 初始化

  * 默认初始化

    * int *p;
      * 随机值，因为编译器认为p的值都是地址，所以也可以说是一个非法地址。

  * 赋值初始化

    * 字面值形式

      * ```c
        int a=10;
        int *p=&a;
        int *q=0;
        int *r=NULL;
        ```

        * &取地址符号，只能用于左值，不能用于右值，意味着不能用于常量，表达式。
        * 指针只能赋值地址值，所以用&取变量地址，唯一的例外是0或者NULL。
          * **指针赋值为0或NULL表示空指针。**
          * NULL本质就是C标准库文件中定义的符号常量，其值就是0，用NULL表示空指针，逻辑上合理一点，不然直接赋值0，不像是一个地址。

    * 变量形式

      * ```c
        int a=10;
        int *p=&a;
        int *q=p;
        ```

* **指针类型**

  * 地址

    * 内存就是一个字节数组，地址是下标，一个字节是值，所以一个地址底层只能对应一个字节。

  * 作用

    * 指示所指对象的大小

      * C语言一个变量或数据结构往往大于一个字节，每个字节对应一个地址，那么这个存储单元就对应许多地址，那么如何通过单个地址访问多字节数据块？。

        * 单个变量或数据结构往往是紧密相邻的，即所有字节是顺序挨着一起的，所以这块存储单元就对应了内存字节数组中的一段。所以访问一个范围，常用就两种方案:
          * 起始地址+终止地址
          * 起始地址+偏移(起点终点之间)

      * **指针正是采用了起始地址+偏移的方式通过一个地址访问多字节的存储块。**

        * **指针存储的地址值是对应数据结构的第一个字节的地址**

        * **指针的类型告诉编译器从这个地址所指字节开始读取多少个字节**

          * ```c
            int a =10;
            int *p=&a;
            ```

            * p存储的地址值是a变量4个字节中的第一个字节的地址。
            * int*p中的int告诉编译器指针所指对象的类型，本质是告诉编译器该对象的大小，从而编译器决定从这个地址开始读取多少个字节。
      
    * 指定单位偏移量
    
      * 指针计算时的单位偏移量由指针类型决定，指针所指对象类型多大，那么单位偏移量就是多大。
        * char *p; p++； 指针移动一个字节
        * int *p; p++; 指针移动4个字节。
  
* void* 指针

  * 通用指针
    * 指向任何对象的指针都可以转换为void*类型，且不会丢失信息。
    * 如果将结果在转换为初始指针类型，则可以恢复初始指针。


##### 3. 指针使用

* *p

  * ```c
    int a=10;
    int *p=&a;
    *p=10;
    ```

    * 使用星号加指针名表示使用指针所指元素，就这么简单。
      * p==&a;  *p==a   完全等价
    * *+指针形式同直接使用所指元素的名字一模一样，没有任何特殊之处。

* 只用指针本体。

  * 指针合法运算
    * 赋值运算
    
      * ```c
        int a;
        int *p =&a;
        int *q=p;
        int *p=NULL;
        int *p=0;
        p+=1;
        p=q-3;
        ```
    
        * 左操作数:指针
        * 右操作数:指针、&左值、0或NULL、指针和整数的算术表达式
    
    * 比较运算
    
      * <, <=, > ,>=, ==, !=
        * 操作数:指针、0或NULL
        * 任意两个指针比较
          * ==，!=简单，不提了
          * <, <=, >, >=
            * 如果两个指针都指向同一个数组的元素**或者数组最后一个元素的下一个元素**，那么p<q表示，p指的元素在q指的元素之前,>同理
            * 如果两个指针没啥关系，那么可以比较，但是C语言没定义比较的具体意义。
        * 指针和0或NULL比较
          * ==, !=常用，判断是否是空指针
          * 其他少用，不过一般如果指针是空指针,那么==0， <0为true,非空，那么!=0, >0位true
    
    * 自增自减
    
      * p++, p--
        * 移动单位偏移量
    
    * 算术表达式
    
      * +, -
        * 支持指针和整数之间的加减法运算
        * 如果两个指针指向同一个数组中的元素，那么这两个指针还支持减法运算。
        * p+i,p-i  表示p左右移动i个单位偏移量之后的地址。
        * p-q-1 表示p,q所指数组元素中间有多少个元素

## 3.3 数组变量

#### 0. 数组和指针

##### 0.1 数组

* 数组就是多个元素的集合，所有元素按照顺序存储在内存的一段连续存储空间中。
* 使用[]定义数组和使用数组元素
* 定义时表示数组长度的必须是一个常量或常量表达式，因为编译器会在编译期间就确定数组的长度。

##### 0.2 常量指针

* 数组基本等同于常量指针(有一点点区别)
  * 同
    * 数组是一个指针，它的值是数组存储单元的第一个字节的地址。
    * 它的类型是数组元素类型
    * 它的值不可修改，所以是常量指针。
    * 它的使用同普通的常量指针一模一样
      * **总结就是数组名就是一个指向第一个数组元素的常量指针。**
    
  * 异
  
    * ```c
      int *p;
      int p[10];
      ```
  
      * 只在定义时有区别
        * 定义一个指针时，永远只分配8B空间。
        * 定义一个数组时，会分配实际的数组大小的空间。
  
* []

  * 定义时

    * int a[10]   分配10个int的空间(一个例外就是作为函数参数)

  * 使用时

    * **a[i]会被翻译为 *(a+i)** ，**因此a[i]==*(a+i); &a[i]=a+i**

      * 所以以后分析二维数组的时候，不要想具体的指针是什么，就从编译器角度考虑，把a[i]翻译成*(a+i)就行了，其他别多想。

    * **所以a[i]没啥特殊的，编译器就直接翻译成*(a+i)**,所以这就意味着a只要是个指针就行，是不是所谓"数组"，根本无所谓。

      * 所以这就是C语言没有下标检查的本质原因，因为数组并不特殊，C语言完全没有维护数组的长度信息，只是把它当做一个常量指针，然后移动使用罢了。

      * 因为指针可以左右移动，p+i, p-i都行，所以p[-1],p[-2]也是合法的，所以a[i]直接翻译，没有任何特殊之处。

      * 至于移动到哪儿，访问新地方的值合不合法，完全靠程序员维护。。。。

* 总结

  * **所以所谓数组就是一个指向第一个数组元素的常量指针，a[i]就是*(a+i)的语法糖仅此而已。唯一的区别就是定义的时候会分配容纳所有数组元素的空间。**

##### 0.3 指向数组元素的指针

* 经常使用指向数组元素的一个或多个指针操作数组，除了正常的数组元素之外，
* C语言定义保证数组末尾之后的第一个元素的指针算术运算可以正确执行


##### 0.3 数组作为函数参数

* 如果函数参数是一个数组，那么并不会真正定义一个局部数组，**而是根据参数形式定义一个合适的指针**。编译器自动忽略第一个数组维度的长度信息，对是忽略。

  * ```c
    int test(int a[])
    int test(int a[10])
    int test(int a[1002])
    int test(int *a)
    //以上四个函数原型完全相同，第一维长度信息完全忽略，想写多少都可以
    //对于多维数组，第一维忽略，其他不能忽略，因为编译器要根据这个信息推测指针的累心
    int test(int a[][10])
    int test(int a[10][10])
    int test(int (*a)[10])
    //三个函数原型等价，合适的指针就是指向一个10个int组成数组(内存块)的指针。
    ```

##### 0.4 二维数组和指向指针的指针

* ```c
  int b;
  int *p=&b;
  int **a=&p;
  int b[5][5];
  ```

  * a,p是指针
    * p指向一个int型对象， 值是int对象第一个字节的地址，单位偏移是4B
    * a指向一个int *指针对象，值是p的第一个字节的地址，单位偏移是8B
  * b是二维数组，每个元素是一个一维数组，所以b[0]\(*(b+0))是一个一维数组，所以b[0]是一个常量指针
    * b[0]指向一个int型对象，值是整个二维数组内存块的第一个字节的地址，单位偏移是4B
    * b指向一个长度为5的一维数组，值是整个二维数组内存块的第一个字节的地址，单位偏移是20B
  * 所以逻辑上讲二维数组也是指向指针的指针，区别在于
    * 普通指向指针的指针的值和所指的指针的值不相同，而且其偏移量固定是8B
    * 二维数组的地址值和其所指的一维数组的地址值相同，其偏移不是固定的而是一维数组所占空间的大小。

##### 0.5 二维数组和指针数组

* ```c
  int a[10][10];
  int *b[10];
  ```

  * a二维数组，每个元素是长度为10的一维数组，分配4\*10*10 400B空间
  * b一维数组，每个元素是一个int*指针，分配8\*10 80B空间
    * 如果b的每个元素也指向一个数组，那么逻辑上b也成了二维数组，但是相比a，好处就是b的每个元素指向的数组长度可以不相同，很灵活。

#### 1. 数值数组

##### 1.1 定义

* 默认初始化

  * ```c
    int a[10];
    ```

    * 如果是外部或静态变量，每个元素初始化为0
    * 如果是普通局部变量，每个元素未定义随机值。

* 赋值初始化

  * 初始化表达式列表(简称初值表达式)

    > {}表示列表，其中逗号分开的是初始化表达式

    * 常量初始化表达式

      * ```c
        int a[]={1,2,3,4,5,6};
        ```

        * 省略数组长度，编译器把初始化表达式个数作为数组长度。

      * ```c
        int a[]={1,2,3,4,5,6};
        ```

        * 不省略数组长度，假设数组长度为n,初始化表达式个数为m
          * n>m
            * 不论外部或静态或局部变量，没有初始化表达式的元素初始化为0
          * n=m
          * n<m
            * 报错
      

#### 2. 字符数组

##### 2.1 定义

* 默认初始化

  * ```c
    char a[10];
    ```

    * 如果是外部或静态变量，每个元素初始化为'\\0'
    * 如果是普通局部变量，每个元素未定义随机值。

* 赋值初始化

  * 初始化表达列表

    * 常量初始化表达式
  
      * ```c
        char a[]={'1','b','c'};
        ```

        * 省略数组长度，编译器把初始化表达式个数作为数组长度
  
      
        * 不省略，同数值数组，区别是如果n>m，那么不够的初始化为'\\0'
  
  * 字符串字面值
  
    * ```c
      char a[]="nmsl"  <==> char a[]={'n','m','s','l','\0'}
      ```
  
      * 所有字符串字面值默认都是以'\\0'结尾的匿名常量字符数组罢了。
      * 不省略的话同上，只要注意字符串末尾一定有'\\0'就行了。

#### 3. 字符串

* 字面值
  * C语言提供用双引号括起来的字面值表示字符串，本质是'\\0'结尾的字符数组。
* char *
  * 可以用 char * b= "hello"形式方便的使用字符串，而不用字符数组形式。
  * 其本质是定义了一个字符指针b指向匿名字符数组的第一个字符，即h.
  * 所以```char *b="hello"  <==>  char a[]="hello", char *b=a```
    * 区别就是前者存储hello的字符数组是匿名的，后者是a。

## 3.4 结构

##### 1. 概念

* 结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。
* 结构可以将不同变量组织成一个单元使用，存储时根据对齐要求将所有变量存储在相邻的一块区域内。
  * 因为对齐要求，结构总的存储大小不一定等于所有结构中的变量的存储大小的和。
  * 使用sizeof可以返回结构变量的实际存储空间大小

##### 2. 类型声明

* ```c
  struct name {body};
  struct name
  {
    body
  }；
  ```

  * 因为结构类似自定义数据类型，所以以上形式没有申明任何变量，仅仅是声明了一个结构类型name.
  * 这个自定义的类型标识符name称为结构标记

##### 3. 声明和定义

> 结构也没有只声明结构却不定义即不分配存储空间的语法，所以声明定义一起谈。

* 形式

  * 类型声明的同时定义初始化结构对象test, 跟int test的形式基本一样，只是略微复杂一点

    * ```c
      struct name {body}  test,test1;
      struct name
      {body}test，test1;
      ```

  * 首先结构类型声明，然后直接用结构标记定义结构变量test,这种更常见。

    * ```c
      struct name {body};
      struct name test,test1;  //虽然已经声明了name结构标记，但是C中凡是要使用结构类型名name的地方，都要前面加struct, C++就不用。
      ```

* 注

  * 因为访问结构成员必须利用结构变量名字，所以结构成员的名字可以和外面的变量重名，
  * 不可以在结构中定义自身的结构变量，但是可以声明自身的结构指针。                     

* 定义初始化

  > 为了简洁，均以先单独声明结构类型，然后再使用结构标记定义变量的方式演示。

  * 默认初始化

    * ```c
      struct point
      {
          int x;
          int y;
      };
      struct point p1,p2;
      ```

  * 赋值初始化

    * 初始表达式列表(简称初值列表)

      * ```c
        struct point p1={1,2};
        ```

    * 同类型变量

      * ```C
        struct point p1=p2;
        ```

##### 4. 使用

* 合法运算

  * 整体赋值，&取地址，访问结构成员。

  * 同其他任何数据结构一样，结构的指针的地址值是整个结构存储单元的第一个字节的地址,声明如下

    * ```c
      struct point {body} *p1;
      struct point *p2;
      ```

* 访问结构成员

  * . 

    * 结构变量名+.+结构成员名

    * ```c
      struct point {int x,y} p;
      int z=p.x + p.y
      ```

  * ->

    * 结构指针+"->"+结构成员名

    * (*p).x <==>  p->x

    * ```c
      struct point {int x,y} pt;
      struct point *p=&pt;
      int z=p->x+p->y;
      ```

## 3.5 联合

##### 1.概念

* 官方

  * 联合是可以(在不同时刻)保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对齐要求。

  * 联合提供了一种方式，以在单块存储区中管理不同类型的数据，而不需要在程序中嵌入任何同机器有关的信息。

* 人话

  * 联合本质就是一个特殊的结构
    * 也是变量的集合，**但是联合只提供可以容纳最大成员的存储空间**，并且假设任意时刻只有一个成员使用这块存储单元，即假设这些成员是互斥的。
    * 所以联合适用于那些空间限制严重，并且变量不会同时使用，任何时候只会使用一个联合成员。

  * 访问结构成员时，编译器根据不同的偏移访问对应的结构成员

  * 而访问联合成员时偏移都是0，也就是访问任何联合成员都是从存储单元的第一个字节处开始。

##### 2. 类型声明

* 和结构类型声明一模一样，关键字由struct换为union即可。

##### 3. 声明和定义

* 除了初始化，定义和声明和结构一模一样，关键字换为union

* 初始化

  * 不管是赋值初始化或初值列表初始化，联合只会初始化第一个成员。

  * ```c
    union test
    {
        int a;
        double b;
        char c;
    };
    union test x={1.1};  <==> union test x;  x.a=1.1;
    union test y=x;      <==> union test y;  y.a=x.a;
    ```

##### 4. 使用

* 合法运算

  * 同结构，整体赋值，复制，取地址，访问联合成员

* 赋值

  * 同上面初始化，只会赋值第一个成员，以上面为例就是把右面联合的前四个B复制到左面联合的前4B。

* 访问成员

  * 联合所有成员共用一段存储空间，所以访问任何成员都是从起始位置开始，根据成员类型编译器读取对应的字节。

  * 以上为例 x.a, x.b, x.c分别从起始位置读取4，8，1B。

  * 所以这就要求程序员负责要访问的成员是刚刚赋值的成员

    * ```c
      x.a=10;
      int a=x.a;
      x.c='b';
      char c=x.c;
      ```

  * 如果赋值与取值不匹配，那么结果未定义，编译器只是按照取值类型从起始位置读取字节数。

    * ```c
      x.a=10;
      char c=x.c;
      //c未定义
      ```

## 3.6 函数

> function

### 2.1 声明和定义和作用域

#### 2.1.1 声明

* 返回值类型 函数名(参数列表);
  * 省略返回值类型，那么默认为int
  * 参数列表可以指明形参名，也可以省略

* 函数的声明也叫函数原型
* 函数可以多次声明，即函数原型可以多次出现
* 可以在函数内部声明别的函数，即函数原型也可以出现在函数内部。

#### 2.1.2 定义

* ```c
  [static] 返回值类型 函数名(参数列表)
  {
      body;
  }
  ```

  * 同变量，定义包含声明。
  * 加static表示静态函数
  * 省略返回值类型，默认int，如果想表示返回值类型为空，可以用void作为返回值类型
  * **函数的形式参数就是定义在函数内部的局部变量，仅此而已，别多想**
    * 如果参数是一个数组定义，那么不会真正定义一个数组，不会分配储存空间，而是定义一个合适的指针。
  
* 函数内部不能定义函数，但是可以声明。

#### 2.1.3 作用域

* 函数名同外部变量名基本一模一样
  * 普通函数
    * 全局作用域，所有源文件都可用
      * 定义全局变量的文件，作用域为定义或声明始到文件尾部
      * 其他文件，需要有函数原型才能使用，作用域从函数原型声明到文件尾。
  * 静态函数(加了static限定的函数)
    * 文件作用域
      * 仅限定义文件使用，作用域从定义或声明始到文件尾。
      * 其他文件不可用，即使声明函数原型也没用
* 有一点区别
  * 外部变量名只有在声明或定义之后才能使用。
  * 函数名能在声明或定义之前使用，编译器根据()函数调用符号推断这是个函数名，然后假定它的返回值是int，就这么用，编译能通过，但是会报warning。
    * 但是最好不要这样。

### 2.2 参数

* 值传递
  * C语言只有一种传参方式就是值传递。
  * **本质就是被调函数利用其调用者的实际参数赋值初始化自己的形式参数。**

### 2.3 返回值

* 每个函数都可以有或没有返回值
  * 如果有返回值的话，除了main函数之外的所有函数返回值返回给其调用者函数。

* main函数的返回值返回给其执行环境。
  * 类似shell中执行ls，ls返回值返回给其执行环境shell
  
* return exit

  * return [表达式]
    * return语句用于将控制从函数返回给调用者。
    * 当return语句后跟一个表达式时，表达式的值将返回给函数调用者。
    * 像通过赋值操作转换类型那样，该表达式将被转换为它所在的函数的返回值类型。
    * 控制到达函数的结尾等价于一个不带表达式的return语句。这两种情况下，返回值未定义。
  * exit(标准库函数)

    * 返回程序的执行状态信息。


### 2.4 通信

* 函数之间通信可以通过参数，函数返回值以及外部变量进行。

2.5 main函数

* c程序的起点就是main函数，即整个程序从main函数处执行
* int main(int argc , char *argv[])
  * Unix环境执行c程序时候，可以从执行环境传参。
  * argc表示参数数量，程序名是第一个参数，所以argc>=1;
  * argv 字符串数组，每个字符串代表一个参数
  * C语言标准定义argv[argc]为空指针。

### 2.6 函数指针

* 指向函数的指针就是函数指针

  * 至于函数指针的地址值是哪一个，我猜测是内存中存储源程序区域中的该函数首行对应的第一个字节的地址。

* 定义使用

  * ```c
    int add(int a, int b);
    int (*p)(int,int)=add;
    int (*p)(int,int)=&add;
    p(10,2);
    (*p)(10,2);
    ```

    * 简而言之，&add==add ,所以赋值用这两个形式都行。
    * p==*p==add  所以用这三个都行。
    * 不过我建议把函数名当做指针，赋值时使用 p=add，使用时直接用p,这样不用\*和\&，和通常变量的指针保持一致

# 3 表达式

## 3.1 定义

* 表达式与语句

  * 有值的语句就是表达式
  * 所以一个单一的变量也是一个表达式。

* 表达式形式

  * 操作符+操作数

  * 操作数

    * 表达式允许嵌套，即表达式本身可以作为操作数

    * ```c
      int a,b;
      a+b;   //操作符+操作数型
      a;	   //操作数型
      ```
  
* **表达式的值**

  * 不管使用表达式与否，只要表达式出现在程序执行流程中，
  * 程序都会对表达式求一个值，所以每个表达式都有一个值
  * 既然有值，那么就有存储对象，所以每个表达式都会有一个匿名对象存储表达式的值
    * **所以一个表达式其实语法上就类似一个"变量"**。
      * 但这个变量跟通常意义上的变量又有所不同，它的值可以变，但是我们无法直接修改它。
      * 因为表达式的值存储在一个匿名对象中，类似字面值一样，我们无法访问。
      * 但是它又和字面值不同，字面值一定是一个常量，它不会变。但是表达式的值会在运行时变化。
  * 表达式的类型取决于表达式的结果对象的类型，
    * 所以我们一般说表达式类型就实际指代的是表达式结果对象的类型。
  
* 常量表达式

  * 仅仅包含常量的表达式，**所以表达式值在编译时就确定了**，之后不会变化，就相当于一个普通的常量。
  * 因为单个常量也是常量表达式，所以后面经常用"常量表达式"代指常量表达式和普通的常量,
  * 同理用表达式代指表达式或者普通变量或者函数调用，本质都是一个可变值。

## 3.2 操作数和操作符

#### 3.2.1 操作数

* 凡是有值的单个对象都可以作为操作数
* 操作数也可以是表达式

#### 3.2.2 操作符

##### 1. 算术运算符

* 算术表达式

  * 算术运算符连接的是算术表达式，**值是实际的结果。**,值得类型是表达式类型转换的公共类型。

* 表

  * | Operator       | Meaning              |
    | -------------- | -------------------- |
    | +, -, * , /, % | 加减乘除，取摸(求余) |

    * 整数除法会截断小数部分。
    * 取余只能用于整型，不能用于浮点型。
      * 当有负整数形式时，余数符号取决于具体硬件。

##### 2. 自增自减运算符

* 表达式的值
  * 前置是变量自增自减后的值，后置是变量自增自减前的值

* 左值
  * 自增自减只能用于变量，不能用于表达式。
  * 因为变量是左值，我们可以修改，表达式值我们无法直接修改，因为其存储对象是匿名的。
* ++， --
  * 自增1，自减1

##### 3. 位运算符

* 表达式的值

  * 实际计算后的结果

* 操作数限制

  * 只能作用于整型操作数

* 表

  * | Operator    | Meaning                                                      |
    | ----------- | ------------------------------------------------------------ |
    | &, \|, ~, ^ | 按位与或非,异或                                              |
    | <<, >>      | 左移右移。左移补0，右移取决于机器，补0逻辑右移，补符号位算术右移。 |

##### 4.关系和逻辑运算符

* 关系表达式

  * 关系和逻辑运算符连接的是逻辑表达式，**值是0或1**，取决于关系的真或假。

* 表

  * | Operator                     | Meaning                                      |
    | ---------------------------- | -------------------------------------------- |
    | >,    >=,   <,   <=,  ==, != | 大于，大于等于，小于，小于等于，等于，不等于 |
    | &&, \|\| , !                 | 与或非                                       |

    * 二元逻辑运算符 &&和||都规定了从左到右的求值顺序并且是短路求值。
      * &&前面为真后面才继续求值，||前面为假后面才继续求值。

##### 5. 赋值运算符

* 赋值表达式

  * 有赋值运算符的是赋值表达式，表达式的值是赋值完成后左操作数的值，类型是左操作数的类型。

* 表

  * | Operator          | Meaning                                                      |
    | ----------------- | ------------------------------------------------------------ |
    | =                 |                                                              |
    | +=, -=, *=, /=,%= | a+=2,以前老是翻译为a=a+2,其实不用翻译，直接理解为a增加2就行了 |
    | <<=,>>=,&=,\|=,^= |                                                              |

##### 6. 条件运算符

* 形式
  * expr1?expr2:expr3
    * expr1为真，执行expr2,为假执行expr3

* 条件表达式
  * 条件运算符参与的是条件表达式，值可能是expr2或expr3的类型。
  * 但是值的类型跟算术表达式差不多，取决于条件表达式整体的转换的公共类型，跟expr1真假无关。
    * 例如expr2值为int型，expr3值为double型，那么最终条件表达式的值类型为double型，与真假无关。

##### 7. 函数调用运算符

##### 8. 数组引用运算符

##### 8. 逗号运算符

* 定义
  * 不是所有的逗号都是逗号运算符，函数参数列表和定义多个变量语句中的逗号就不是。
* 执行
  * 被逗号分隔的一对表达式将按照从左到右的顺序进行求值。

#### 3.2.3 运算符优先级、结合性别与求值顺序

##### 1. 优先级和结合性

* 优先级规定了运算符优先级不同时的计算顺序——先计算优先级高的那个运算符

* 结合性规定了运算符优先级相同时的计算顺序——按照结合性顺序依次计算运算符

  * | Opeator                   | Meaning                                    | 结合性                 |
    | ------------------------- | ------------------------------------------ | ---------------------- |
    | ()    []   ->   .         | 函数调用，访问结构成员                     | 左结合(即从左到右顺序) |
    | !   ~  ++  --  +  -  *  & | 逻辑非，按位取反，正负号，指针访问，取地址 | **右结合**             |
    | *   /      %              | 乘除取余                                   | 左结合                 |
    | +  -                      | 加减                                       | 左结合                 |
    | <<  >>                    | 左右移                                     | 左结合                 |
    | <   <=  > >=              | 小于，小于等于                             | 左结合                 |
    | == !=                     | 等于，不等于                               | 左结合                 |
    | &                         | 按位与                                     | 左结合                 |
    | ^                         | 按位异或                                   | 左结合                 |
    | \|                        | 按位或                                     | 左结合                 |
    | &&                        | 逻辑与                                     | 左结合                 |
    | \|\|                      | 逻辑或                                     | 左结合                 |
    | ?:                        | 条件运算                                   | **右结合**             |
    | =  +=  -=  *=   /= %= &=  | 复合赋值                                   | **右结合**             |
    | ^= \|= <<= >>=            | 复合赋值                                   | 左结合                 |
    | ,                         | 逗号运算符                                 | 左结合                 |

##### 2. 求值顺序

* 二元运算符两边操作数为普通变量，不存在求值问题，直接计算即可。
* 当两边操作数为表达式，那么计算之前就要先求出表达式的值。
  * C语言大部分二元运算符没有规定求值顺序，有可能先求左表达式或右表达式，取决于具体实现。
  * &&， || 规定从左到右求值，并且&&左边值为真才继续求值，||左边值为假才继续求值。
  * ，运算符从左到右依次求值。
* 应该尽量避免计算结果与求值顺序有关。

## 3.3 类型转换

#### 3.3.1 概念

* 数值类型转换

  * 最常见的类型转换就是数值类型之间的转换。

  * 本质是现在的数值计算都是2的补码表示形式，所以即使表示同一个值，数值类型不同，值的表现形式也不同，所以计算不同类型数时需要首先同意转换为一种数据类型。

* 原变量不变

  * 原变量是不能修改的，所以如何完成数值类型转换，那么就是创建类型为变量要转为的类型的匿名变量并初始化为待转变量的值，然后利用这个匿名对象计算，计算完成后销毁该对象。

  * **切记转换这个词比较有迷惑性，变量是不会变的，所谓转换其实是新建一个和变量值相同但是类型不同的匿名对象完成计算然后销毁**

    * ```c
      int a =10;  long b = 100;
      a+b;
      //a+b这是一个表达式，求值时,需要将a转为long类型，说是这么说的，但是a的值是不会变得。
      //我们都知道，表达式都是有一个值的，这个值得有地方保存，所以一定有一个保存表达式值的匿名对象
      //如果只需要转换一个类型，那么我们就可以利用这个匿名对象，创建一个long匿名对象保存a的值，然后把b加进来就行了。。
      //如果有大于1个的需要类型转换的变量，那么还要创建更多的匿名对象
      ```

#### 3.3.2 分类

##### 1. 自动(隐式)类型转换

* 定义
  * 很多情况下C语言进行自动(隐式)类型转换。
  * 转换的原则一般是"小"转"大"，尽量不损失数值精度。
    * 算术表达式转换一般不损失精度
    * 赋值表达式转换则取决于具体转换
* 分类
  * 算术运算表达式
    * 二元运算符两边操作数要转为同一类型。
    * 转换规则
      * 详细版
        * 见《c语言程序设计第二版》173页附录A.6
      * 如果表达式中不涉及无符号整数，那么用下列规则即可
        * 一个操作数为long double, 另一个也转long double
        * 一个操作数double，另一个也转double
        * 一个操作数为float，另一个也转float
        * char和short操作数都转int(本质是因为最少都是为32位设计的加减乘除)
        * 一个操作数为long，另一个转long
        * 如果一个表达式涉及多种类型参与，那么首先会转换为一个公共类型进行运算。表达式的值的类型将会是这个公共类型。
  * 赋值
    * 赋值号右边表达式的值要转为左边的类型。
    * 赋值表达式，函数参数传递等凡是需要赋值的地方都会隐式类型转换。

##### 2. 强制类型转换

* 定义

  * 强制类型转换，程序员手动强制转换类型

* 用法

  * (类型名) 表达式

    * ```c
      (double)(2+3);
      char a='b';
      (int)a;
      ```

  * 切记类型转换的本质不是修改原来的变量或者表达式，而是新建一个同值的符合类型的匿名对象，然后用完后销毁。

## 3.4 表达式形式

> 表达式类型就是表达式的值的类型
>
> 这里表达式形式是递归定义的主要跟操作符有关的表达式的几种形式，
>
> 表达式涉及的操作符优先级依次降低

#### 3.4.1 初等表达式

* 递归定义

  * ```c
  初等表达式:
  	标识符
      常量
      字符串
      (表达式)
    ```

  * 加括号的表达式是初等表达式，常用语if条件部分，所以括号本身不是if语句的一部分。

#### 3.4.2 后缀表达式


* 递归定义
  
  
  * 后缀表达式中的运算符优先级相同，左结合(从左到右顺序结合)
  
  * ```c
    后缀表达式:
    初等表达式
      后缀表达式[表达式]
      后缀表达式(参数表达式表)
      后缀表达式.标识符
      后缀表达式->标识符
      后缀表达式++
      后缀表达式--
    参数表达式表:
    赋值表达式
      参数表达式表，赋值表达式
    ```
  
  * 上面的形式表示递归定义，单一初等表达式是后缀表达式，后缀表达式后面加不同后缀生成新的后缀表达式。
  
* 数组引用


  * 带方括号的是数组引用后缀表达式。
  * 方括号前面的后缀表达式必须是指向T类型的指针
  * 数组引用的结果的类型为T
  * 方括号内表达式值必须是整型
  * 表达式E1[E2]等价于，或这会被翻译为*(E1+E2)

* 函数调用


  * 带圆括号后缀的是函数调用表达式，括号内是实际参数
  * 函数调用严格值传递，本质是用实际参数一一对应赋值形式参数。

* 结构联合应用


  * 后缀表达式后跟.或->仍然是后缀表达式
  * .前面的表达式类型必须是结构或联合，后面的标识符必须是结构或联合的成员的名字
  * ->前面的表达式类型必须是结构或联合的指针

* ++,--


  * 表达式必须是一个左值。
  * 先用后增。
  * 其结果不是左值


#### 3.4.3 一元表达式

* 递归定义

  * 表达式中一元运算符优先级相同，右结合。

  * ```
    一元表达式:
        后缀表达式
        ++一元表达式
        --一元表达式
        一元运算符 强制类型转换表达式
        sizeof 一元表达式
        sizeof(类型名)
        
    一元运算符:one of
        & * + - ~ ！
        
    强制类型转换表达式:
        一元表达式
        (类型名) 强制类型转换表达式
    ```

* ++，--

  * 操作数必须是左值，先增后用，
  * 其结果不是左值

* &

  * 取地址，操作数必须是左值或函数对象，
  * 得到的结果是一个指针

* *

  * 间接寻址运算符，返回操作数指向的对象或函数
  * 结果是一个左值

* +,-

  * 正负

* ~

  * 按位取反，操作数必须是整型

* ！

  * 逻辑非
  * 操作数必须是算术类型或指针

#### 3.4.4 强制类型转换表达式

* 递归定义

  * 以括号括起来的类型名开头的一元表达式将导致表达式的值被转换为指定的类型

  * ```
    强制类型转换表达式:
        一元表达式
        (类型名) 强制类型转换表达式
    ```

* 包含强制类型转换的表达式不是左值

  * 因为本质是生成了一个符合类型要求的匿名对象。

#### 3.4.5 乘法类表达式

* 递归定义

  * 优先级同，左结合

  * ```
    乘法类表达式:
    	强制类型转换表达式
    	乘法类表达式*强制类型转换表达式
    	乘法类表达式/强制类型转换表达式
    	乘法类表达式%强制类型转换表达式
    ```

  * *，/

    * 操作数必须为算术类型

  * %

    * 操作数必须为整型。
    * 如果两个操作数非负，余数正确
    * 如果同负或一正一负，余数取决于具体实现，C只保证余数绝对值小于除数绝对值。

#### 3.3.6 加法类表达式

* 递归定义

  * 优先级同，左结合。

  * ```
    加法类表达式:
    	乘法类表达式
    	加法类表达式+乘法类表达式
    	加法类表达式-乘法类表达式
    ```

* +，-

  * 操作数可以为算术类型或者指针
  * 两个操作数不能都是指针，除非
    * 只有指向同一数组的元素(包括最后一个元素之后的一个元素)的两个指针可以相减

#### 3.3.7 移位表达式

* 递归定义

  * 优先级同，左结合

  *  ```
     移位表达式:
     	加法类表达式
     	移位表达式<<加法类表达式
     	移位表达式>>加法类表达式
     ```

* <<

  * 左移，右边补0，不溢出相当于乘以2的n次方，n为移位个数
  * 操作数必须为整型(没要求是左值,右移也是)

* \>>

  * 右移，补0逻辑右移，补符号位算术右移，不溢出相当于除2的n次方。
  * 操作数必须为整型

#### 3.3.8 关系表达式

* 递归定义

  * 优先级同，左结合，

  * 结合性没啥意义，因为单个比较的结果都是0或1，所以编译器不允许多个关系运算符同时出现，否则不符合逻辑意义

    * a<b<c要写成 a<b&&b<c

  * ```
    关系表达式:
    	移位表达式
    	关系表达式<移位表达式
    	关系表达式<=移位表达式
    	关系表达式>移位表达式
    	关系表达式>=移位表达式
    ```

* <,<=,>,>=

  * 结果都是int型，值为0或1
  * 操作数同为算术类型或指向同一类型元素的两个指针。
  * 比较两个指针根据地址空间中的相对位置比较

#### 3.3.9 相等类表达式

* 递归定义

  * 优先级同，左结合,没意义，理由同上

  * ```
    相等类表达式:
    	关系表达式
    	相等类表达式==关系表达式
    	相等类表达式!=关系表达式
    ```

* ==，！=

  * 操作数同为算术类型或执行同一类型元素的两个指针，
  * 或者0或NULL与单个指针
  * 值0或1

#### 3.3.10 按位表达式

* 递归定义

  * 优先级依次降低: &, ^,|。优先级不同，所以按优先级结合就行

  * ```
    按位表达式:
    	相等类表达式
    	按位表达式&相等类表达式
    	按位表达式^相等类表达式
    	按位表达式|相等类表达式
    ```

* &,^,|

  * 两边的表达式必须为整型

#### 3.3.11 逻辑表达式

* 递归定义

  * 优先级依次降低: &&， ||。优先级不同，所以按优先级结合就行

  * ```
    逻辑表达式:
    	按位表达式
    	逻辑表达式&&按位表达式
    	逻辑表达式||按位表达式
    ```

* &&，||

  * 结果都是int型，值0或1.
  * 操作数可以是算术类型或指针，不要求同为指针或算数类型
  * 规定了从左到右的求值顺序并且是短路求值

#### 3.3.12 条件表达式

* 递归定义

  * ```
    条件表达式:
    	逻辑表达式
    	逻辑表达式？表达式1：表达式2
    ```

* 为真执行表达式1，为假执行表达式2

#### 3.3.13 赋值表达式

* 递归定义

  * 优先级同，左结合

    ```
    赋值表达式:
    	条件表达式
    	一元表达式 赋值运算符 赋值表达式
    赋值运算符: one of
     = *= /= %= += -= <<= >>= &= ^= |=
    ```

* =

  * 左操作数必须是可修改的左值
  * 赋值表达式的值是左操作数的赋值执行完毕后的值，类型是左操作数的类型。

#### 3.3.14 逗号表达式

* 递归定义

  * 求值次序从左到右

  * ```
    逗号表达式:
    	赋值表达式
    	表达式，赋值表达式
    ```

* ，

  * 左表达式式结果丢弃，最终表达式值和类型同右表达式的值和类型。

#### 3.3.15 常量表达式

* 每个操作数都是常量或常量表达式的表达式是常量表达式。

# 4 流程控制

> flow control

## 4.1 条件(condition)

* 条件部分可以是任意表达式
* 判断流程
  * 执行表达式
  * 得到表达式的值
  * 根据表达式值进行条件判断
    * 0表示假
    * 非0表示真

## 4.2 分支

##### 4.2.1 if语句

* 根据测试结果选分支

  * ```c
    if (expression)
      statement;
    else
      statement;
    if (expression)
      statment
    else if(expression)
      statement
    else
    ```

##### 4.2.2 switch语句

* 根据测试结果选分支

  * ```c
    switch(表达式)
    {
          case 常量表达式：语句序列；
          case 常量表达式：语句序列；
          case 常量表达式：语句序列；
          default:语句序列；         
    }
    ```

  * 常量表达式包括常量表达式和普通的常量。
  * 如果没有break，那么匹配case语句后会自动执行下一个；
  * 加break跳出case语句，不执行下一条。
  * 什么都不匹配，那么默认匹配default语句，default语句最好加break，以防后面在加case语句导致不必要的麻烦。

## 4.3 循环

##### 4.3.1 while和for循环

* 先测试，再循环

  * ```c
    while(expr)
      body;
    for(expr1;expr2;expr3)
      body;
    //没有continue情况下，上面的for循环等价于
    expr1;
    while(expr2)
    {
      body;
      expr3;
    }
    
    ```

* 如果有continue，while直接跳到expr2条件测试，而for循环会执行完expr3之后在跳到expr2测试。

* 条件测试为真，执行循环，为假，终止循环。

* for两个分号不能省略，expr1,expr2,expr3都可以省略，

  * **如果expr2为空，那么表示永真**

##### 4.3.2 do-while循环

* 先执行，再测试

  * ```c
    do
    {
        body;
    }while(expr);  //注意这里分号不能省略
    ```


##### 4.3.3 break和continue

* break
  * 用于switch语句跳出当前switch语句
  * 用于循环跳出当前循环语句
    * 如果有多层嵌套循环，那么只能跳出当前一层循环。
* continue
  * 跳过本次循环，进行下一次循环
    * while,do-while
      * 直接跳到条件测试
    * for
      * 执行完本次expr3之后跳到条件测试

##### 4.3.4 goto语句

* ```c
  goto label;
  label:
  ```

  * label代表goto使用的标号。
  * 标识符后面加冒号就组成一个标号。

# 5. 语句

### 5.1 定义

* 如果不特别指明，语句都是顺序执行的。语句执行都有一定的结果，但没有值

* ```c
  语句:
  	带标号语句
      表达式语句
      复合语句
      选择语句
      循环语句
      跳转语句
  ```

### 5.2 分类

#### 5.2.1 带标号语句

* ```c
  带标号语句:
  	标识符:语句
      case 常量表达时式:语句
      default：语句
  ```

  * 标识符标号的唯一用途就是作为goto语句的跳转目标。标识符的作用域是当前函数。
  * case和default标号用于switch语句。case常量表达式必须是整型

#### 5.2.2 表达式语句

* ```c
  表达式语句:
  	[表达式]
  ```

  * 省略表达式表示空语句
  * 大部分语句为表达式语句
  * 大部分表达式语句为赋值语句或函数调用语句

#### 5.2.3 复合语句(块)

* 当需要把若干条语句作为一条语句使用时，可以使用复合语句(也称为"程序块").函数定义，结构定义，循环语句都是复合语句
* {}

#### 5.2.4 选择语句

* ```c
  选择语句:
  	if(expr) 语句
      if(expr) 语句 else  语句
      switch(expr) 语句
  ```

  * else匹配最近的未匹配else的if
  * switch根据表达式的不同取值将控制转向相应的分支。表达式必须是整型

#### 5.2.5 循环语句

* ```c
  循环语句:
  	while(expr) 语句
      do 语句  while(expr)
      for([expr1];[expr2];[expr3])语句
  ```

#### 5.2.6 跳转语句

* ```c
  跳转语句:
  	goto 标识符;
      continue;
  	break;
  	return [表达式];
  ```

  * goto跳转到标号语句
  * continue跳到下一次循环
  * break终止最内层循环语句
  * return语句用于将控制从函数返回给调用者。
    * 当return语句后跟一个表达式时，表达式的值将返回给函数调用者。
    * 像通过赋值操作转换类型那样，该表达式将被转换为它所在的函数的返回值类型。
    * 控制到达函数的结尾等价于一个不带表达式的return语句。这两种情况下，返回值未定义。

