# C 本体

> 所谓本体就是语言原生支持的操作，无需借助任何外部程序，包括标准库的程序

## 引言

* 本体不支持
  * 复合数据结构直接处理
    * C语言不提供直接处理诸如字符串、集合、列表或数据等复合对象的操作。虽然可以将整个结构作为一个单元进行拷贝，但C语言没有处理整个数组或字符串的操作。
  * 存储管理
    * 除了由函数的局部变量提供的静态定义和堆栈外，C语言没有定义任何存储器分配工具，也不提供堆和无用内存回收工具。
  * 输入输出
    * C语言本身没有提供IO功能，没有READ或WRITE语句，也没有内置的文件访问方法。所有这些高层的机制必须由显式调用的函数提供。
  * 并行
    * C语言只提供简单的单线程控制流，即测试、循环、分组和子程序，它不提供多道程序设计、并行操作、同步和协同例程。
* 语言学家？
  * 有关编程语言的官方标准，即最全最准最细的语言介绍，是给编译器实现者看的，不是给普通程序员看的，所以我们没必要了解所有细节，大概知道整个知识树，用什么细节钻研什么细节就行了。
  * 所以笔记没必要奢求一次性把所有相关只是内容记下来，只需第一遍填充整体的框架，然后以后一遍一遍根据实际应用填充细节即可。

# 1 变量

> 变量或者说数据结构就是语言提供给我们的**可以读写的一块内存的抽象**，仅此而已。

## 1.1 概念

### 1.1.1 内存抽象

* 字节数组
  * 对于程序而言，内存就是一个巨大的字节数组，下标是从0x0000000000000000(64位机器)开始的地址，值是8bit的位pattern。
* 键值对
  * 内存就是一个数组，换言之就是键值对，键是下标，值是值。
  * **所以底层对于内存的访问永远是靠键，即地址。**
  * 语言提供的抽象也是键值对，并且通过键来使用值
    * 只不过语言提供的所谓<变量名-值>、<引用-值>、<指针-值>等键值对
    * 其键的底层本质都是地址访问，只不过编译器隐藏了这一点然后给我们提供抽象罢了。

### 1.1.2 声明、定义、初始化

> declaration , define，initialization

##### 1.声明

* 不给变量分配内存，仅仅声明变量名字和性质。
* 可以理解为声明了键，但是没有对应的值
* 变量可以多次声明

##### 2.定义

* 意义

  * 声明变量、分配内存、构造变量并初始化
  * 可以理解为生成了一个键值对
  * 定义就一定包含了声明。
  * 不可以重定义(当变量还处在生存期)

* 形式

  * ```c
    [限定符]  变量类型 变量名;
    [限定符]  变量类型 变量名1, 变量名2,....;
    [限定符]  变量类型 变量名=值;
    ```

    * 变量名(变量标识符)
      * 数字字母下划线组成
      * 开头不能用数字，也最好不要用下划线，因为很多库函数下划线开头。
      * 语言保留字不能用，对应于保留字，我们一般称自定义的名字为标识符
      * 常量用全大写加下划线。

    * 变量类型
      * 系统预定义的类型和自定义类型。
      * 所有类型变量的值都是位模式
      * 对象的类型决定该对象的取值的集合以及可以对该对象执行的操作

    * 限定符


##### 3.初始化

* 定义变量的时候会执行变量初始化
* 初始化类型
  * 默认初始化
    * 对于局部变量而言就是随机值
    * 对于外部变量和静态变量就是0.
    * 对于结构，类等复杂变量而言就是构造函数设定的默认值。
  * 赋值初始化
    * 初始化表达式
      * 常量表达式(
        * 外部变量、静态变量、局部变量
      * 非常量表达式
        * 局部变量

### 1.1.3 变量、常量、字面值

##### 1. 变量

* 很好理解，值可以变得就是变量
* **变量的值在运行时确定**

##### 2. 常量

* 定义
  * 硬件上一块内存总是可以读写的，所以其抽象叫做变量
  * 出于软件需要，有时要限制变量的修改，那么这个被限制修改的“变量”就是常量
  * **常量的值在编译时确定**
* 分类
  * 字面值常量
  * const 常量
  * #define 常量
  * 常量表达式
  * 枚举常量

##### 3.字面值

*  定义

  * 一种特殊的“变量”，它的键十分特殊，特殊在两点
  
    *  它的键就是它的值的，所以叫字面值。
    *  我们只能读存储字面值的这块内存，而无法修改，因为它是匿名的。
  
* 分类
  
    * 数值字面值
    
      *  不加引号的表示数字字面值
      *  整数支持十进制，八进制(0开头)，十六进制(0x开头，大小写都行)
      *  浮点数支持小数点形式和科学计数法形式
    
  * 字符字面值
    
      * 单引号表示字符字面值
    * 支持常规可输入字符和转义序列
    
  * 字符串字面值
  
    *  双引号表示字符串字面值。
  
    * ```c
    int c=10，b=08，c=0xFF;
    char ch='a',chc='\n',chcc='\123',chccc='011';
    char * str="nmsl"
    ```
  
* 使用

  *  字面值见名知义，十分方便
  *  但是凡是有一定意义的字面值，最好不要随处卵用，例如要用"hello world"作为问候语
  *  那么相比随处乱用，最好定义一个符号常量使用它
    *  #define   HELLO   "hello world"
    *  预处理器会把所有出现HELLO的地方替换为"hello world",相当于全局搜索替换文本。

### 1.1.5 外部变量、局部变量、静态变量

#### 1. 静态变量

* 定义
  * static限定定义的变量是静态变量
  * 在编译时创建并分配存储空间，只能定义初始化一次，程序结束后销毁。
    * 创建时默认初始化为0，赋值初始化的话必须用常量表达式初始化
* 分类
  * static限定的外部变量是静态外部变量
  * static限定的局部变量是静态局部变量

#### 2. 局部变量

* 定义
  * 函数内定义的变量叫局部变量
  * 函数的形参也是局部变量，把他看做局部变量就行了，就这么简单。


* 分类

  > 区别只在于生存期

  * 普通局部变量
    * 普通局部变量在函数执行时创建，执行完毕后销毁，所以理论上函数调用多少次，那么局部变量就会定义初始化多少次。

  * 静态局部变量
    * 静态局部变量编译时创建初始化一次，无论函数调用与否，静态局部变量一直存在到程序结束。

* 小误区

  * ```c
    for(int i=1; i<20; i++)
    {
      int p=10;
    }
    //以前有个愚蠢的想法，这个p是不是每次循环都要重新创建。。
    //显然不会，只会函数调用时第一次遇到后他才是个定义语句，创建，之后每次循环不过就是执行到第4行然后又跳回到第二行执行，编译器知道这是for循环之内，再次遇到这个语句，不会当做定义语句，所以不会在创建一次了
    ```


#### 3. 外部变量

* 定义

  * 定义在所有函数之外，且在全局范围内即所有源文件中只能定义初始化一次，由编译程序分配存储单元
    * 定义时默认初始化为0，赋值初始化的话必须用常量表达式初始化。
  
  * 定义在所有函数之外，所以也叫外部变量，也可以外部变量跟函数是同级的。
  
* 分类

  > 区别只在于作用域

  * 普通外部变量
    * 全局作用域
      * 定义所在文件
        * 作用域从定义位置始到文件尾部
      * 其他文件
        * 需要显式extern声明，作用域从声明位置始到文件结尾。
  * 静态外部变量
    * 文件作用域
      * 从定义位置到文件尾部。
      * 其他文件即使显式extern声明了也不能用

### 1.1.6 生存期和作用域

#### 1. 生存期

> 生存期指变量所在内存块没被释放的这段时间

* 外部变量
  * 外部普通变量或外部静态变量
    * 编译时创建-程序结束时释放
    * 即生存期等于程序生存期。

* 局部变量
  * 普通局部变量
    * 函数执行时创建-函数执行完毕释放

  * 静态局部变量
    * 编译时创建-程序结束时释放，整个程序生命周期内都存在。


#### 2. 作用域

> 就是变量名即标识符这个键的作用范围，就是程序中可以使用该名字的部分。
>
> 外部变量和函数都为外部对象，所以名字作用域基本一模一样。

##### 2.1 外部变量

* 普通外部变量

  * 全局作用域，所有源文件都可使用

    * 定义全局变量的文件，作用域为定义或声明始到文件尾部
    
    * 其他文件，需要显式extern声明后使用，作用域声明始到文件尾部。
    
      * ```c
        //file1.c
        int test;
        int main()
        {}
        //file2.c
        extern int test;
        int main()
        {test=10;}
        ```
  
* 静态外部变量

  * 文件作用域
    * 仅限定义文件使用，作用域从定义或声明始到文件尾。
    * 其他文件不可用，即使extern显式声明也没用。

##### 2.2 函数名

* 普通函数
  * 全局作用域，所有源文件都可用
    * 定义全局变量的文件，作用域为定义或声明始到文件尾部
    * 其他文件，需要有函数原型才能使用，作用域从函数原型声明到文件尾。

* 静态函数(加了static限定的函数)
  * 文件作用域
    * 仅限定义文件使用，作用域从定义或声明始到文件尾。
    * 其他文件不可用，即使声明函数原型也没用


##### 2.3 局部变量

* 不论普通或静态局部变量，都是块作用域，块儿内使用

## 1.2 分类

### 1.2.1 数值变量

#### 1. 类型和范围

* 整型

  * | Type           | C语言要求至少 | 32位硬件典型实现 | 64位硬件典型实现 |
    | -------------- | ------------- | ---------------- | ---------------- |
    | char           | 8bit          | 8bit             | 8bit             |
    | signed char    | 8             | 8                | 8                |
    | unsigned char  | 8             | 8                | 8                |
    | short          | 16            | 16               | 16               |
    | unsigned short | 16            | 16               | 16               |
    | int            | 16            | 32               | 32               |
    | unsigned int   | 16            | 32               | 32               |
    | long           | 32            | 32               | 64               |
    | unsigned long  | 32            | 32               | 64               |

    * C语言要求short和int最少16位，long最少32位，short不能长于int，int不能长于long
    * short和long是 short int 和long int的简写。
    * 具体实现由编译器根据对应硬件平台决定。
    
  * 整型字面值
  
    * 支持十进制普通形式、科学计数法形式，八进制，十六进制  
  
      * 八进制0开头，012，十六进制0x开头(大小写均可)
  
      * ```c
        int a=10, b=012,c=0xff,d=0xFF;
        long nb=2e10;  //2e10表示2乘以10的10次方。
        ```
  
      * 
  
    * 整型字面值的匿名存储对象默认是int类型，如果超范围了，那么就用long类型，也可以手动指定
  
      * l和L结尾，手动指定匿名存储对象为有符号long类型，用8B存储
  
      * u和U结尾，指定为无符号类型
  
        * ```c
          long x=123l,y=133L;
          long x=233ul,y=23u;
          ```
  
  * 字符变量
  
    * 字符变量是比较特殊的一种整型变量，普通整型变量按照2的补码解释，字符变量按照ASCII解释。
  
    * ASCII只定义了7位，所以字符变量的范围限定为0x00~0x7F。
  
    * 字符字面值
  
      * 键盘可直接输入的那么包在单引号内直接输入即可。
  
      * 无法直接输入或者无法显示的字符，可以用转义序列表示。
  
      * 常用转义序列
  
        * | 序列  | 字符           | 序列        | 字符                                            |
          | ----- | -------------- | ----------- | ----------------------------------------------- |
          | '\\n' | 换行           | '\\r'       | 回车                                            |
          | '\\0' | 空字符null     | '\\ooo'     | ASCII中八进制数对应的字符                       |
          | '\\t' | 制表符         | '\\xhh'     | 16进制数对应的字符(16进制大小写都行\\x1F,\\x1f) |
          | '\\?' | 问号也要转义。 | '\\'','\\"' | 单双引号转义                                    |
  
* 浮点型

  * | Type        | 32位硬件典型实现 | 64位硬件典型实现 |
    | ----------- | ---------------- | ---------------- |
    | float       | 4B               | 4B               |
    | double      | 8B               | 8B               |
    | long double | 8B               | 16B              |

    * float 单精度浮点数，double双精度浮点数
    * 具体范围取决于机器。
    
  * 浮点数字面值
  
    * 支持小数点形式和科学计数法形式
  
      * ```c
        double a=0.01   <==>   double a=1e-2   //(1乘以10的负二次方)
        ```
  
    * 默认字面值匿名存储对象类型为double
  
      * 后缀f和F指定为float型
      * 后缀l或L指定为long double类型
        * 如果字面值不是小数，加后缀l，L表示long 型整数，如果是小数表示long double型浮点数。

#### 2. 声明

* extern int x;
  * 只有外部变量声明是单纯的声明，不会定义。
  * 其他的局部变量声明就是定义，定义就是声明。

#### 3. 定义

* [限定符]  整型类型  变量名；

* 浮点类型 变量名；

  * ```c
    signed int a;	
    unsigned int a,b;
    int a=10;
    int a=10,b=20;
    int a=b;
    
    //构建没有初始化，值为随机值
    char var1
    //构建并以字面值初始化，转义字符斜杠用来表示无法输入的或无法显示的字符字面值
    char var1='a',var2='\n',var3='\"', var4='\0',var5='\123'
    //构建并以字符变量初始化。
    char var1='a'
    char var2=var1
    ```
  
  * 限定符signed和unsigned用于整型变量，表示有符号或无符号，省略限定符那么表示有符号，char除外，char取决于机器。

### 1.2.2 枚举

* ```c
  enum names {LP,SSY,ABC};
  enum {SB,CNM,YYDS};
  enum {XX,LP=2, CC=4, DD，FF}; // XX值为1，DD值为5， FF为6
  ```

  * 第一个定义了枚举变量names,3个int型常量LP，SSY，ABC，并且限定names的取值范围只能是这三个整型常量值。
  * 第二个就是定义了三个int整型常量，建立了名字与0，1，2字面值常量之间的联系。
  * 整型常量值没指定默认从0开始递增，如果指定了，那么没指定的那些从最近的指定了的处递增

### 1.2.3 数组变量

#### 0. 数组 

#### 1. 数值数组

##### 1.1 定义

* 默认初始化

  * ```c
    int a[10];
    ```

    * 如果是外部或静态变量，每个元素初始化为0
    * 如果是普通局部变量，每个元素未定义随机值。

* 赋值初始化

  * 初始化表达式列表

    > {}表示列表，其中逗号分开的是初始化表达式

    * 常量初始化表达式

      * ```c
        int a[]={1,2,3,4,5,6};
        ```

        * 省略数组长度，编译器把初始化表达式个数作为数组长度。

      * ```c
        int a[]={1,2,3,4,5,6};
        ```

        * 不省略数组长度，假设数组长度为n,初始化表达式个数为m
          * n>m
            * 不论外部或静态或局部变量，没有初始化表达式的元素初始化为0
          * n=m
          * n<m
            * 报错
      

#### 2. 字符数组

##### 2.1 定义

* 默认初始化

  * ```c
    char a[10];
    ```

    * 如果是外部或静态变量，每个元素初始化为'\\0'
    * 如果是普通局部变量，每个元素未定义随机值。

* 赋值初始化

  * 初始化表达列表

    * 常量初始化表达式
  
      * ```c
        char a[]={'1','b','c'};
        ```

        * 省略数组长度，编译器把初始化表达式个数作为数组长度
  
      
        * 不省略，同数值数组，区别是如果n>m，那么不够的初始化为'\\0'
  
  * 字符串字面值
  
    * ```c
      char a[]="nmsl"  <==> char a[]={'n','m','s','l','\\0'}
      ```
  
      * 所有字符串字面值默认都是以'\\0'结尾的匿名常量字符数组罢了。
      * 不省略的话同上，只要注意字符串末尾一定有'\\0'就行了。

#### 3. 字符串

# 2 函数

> function

## 2.1 声明和定义和作用域

#### 2.1.1 声明

* 返回值类型 函数名(参数列表);
  * 省略返回值类型，那么默认为int
  * 参数列表可以指明形参名，也可以省略

* 函数的声明也叫函数原型
* 函数可以多次声明，即函数原型可以多次出现
* 可以在函数内部声明别的函数，即函数原型也可以出现在函数内部。

#### 2.1.2 定义

* ```c
  [static] 返回值类型 函数名(参数列表)
  {
      body;
  }
  ```

  * 同变量，定义包含声明。
  * 加static表示静态函数
  * 省略返回值类型，默认int，如果想表示返回值类型为空，可以用void作为返回值类型
  * **函数的形式参数就是定义在函数内部的局部变量，仅此而已，别多想**
  
* 函数内部不能定义函数，但是可以声明。

#### 2.1.3 作用域

* 函数名同外部变量名基本一模一样
  * 普通函数
    * 全局作用域，所有源文件都可用
      * 定义全局变量的文件，作用域为定义或声明始到文件尾部
      * 其他文件，需要有函数原型才能使用，作用域从函数原型声明到文件尾。
  * 静态函数(加了static限定的函数)
    * 文件作用域
      * 仅限定义文件使用，作用域从定义或声明始到文件尾。
      * 其他文件不可用，即使声明函数原型也没用
* 有一点区别
  * 外部变量名只有在声明或定义之后才能使用。
  * 函数名能在声明或定义之前使用，编译器根据()函数调用符号推断这是个函数名，然后假定它的返回值是int，就这么用，编译能通过，但是会报warning。
    * 但是最好不要这样。


## 2.2 参数

* 值传递
  * C语言只有一种传参方式就是值传递。
  * **本质就是被调函数利用其调用者的实际参数赋值初始化自己的形式参数。**

## 2.3 返回值

* 每个函数都可以有或没有返回值
  * 如果有返回值的话，除了main函数之外的所有函数返回值返回给其调用者函数。

* main函数的返回值返回给其执行环境。
  * 类似shell中执行ls，ls返回值返回给其执行环境shell

## 2.4 通信

* 函数之间通信可以通过参数，函数返回值以及外部变量进行。

# 3 表达式

## 3.1 定义

* 表达式与语句

  * 除声明定义语句以外，**任何一个去掉分号的语句就是一个表达式**
  * 所以一个单一的变量也是一个表达式。
  * 换言之，任何一个表达式(expression)加上分号就是一个语句(statement).

* 表达式形式

  * 操作符+操作数

  * 操作数

    * 表达式允许嵌套，即表达式本身可以作为操作数

    * ```c
      int a,b;
      a+b;   //操作符+操作数型
      a;	   //操作数型
      ```
  
* **表达式的值**

  * 不管使用表达式与否，只要表达式出现在程序执行流程中，
  * 程序都会对表达式求一个值，所以每个表达式都有一个值
  * 既然有值，那么就有存储对象，所以每个表达式都会有一个匿名对象存储表达式的值
    * **所以一个表达式其实语法上就类似一个"变量"**。
      * 但这个变量跟通常意义上的变量又有所不同，它的值可以变，但是我们无法直接修改它。
      * 因为表达式的值存储在一个匿名对象中，类似字面值一样，我们无法访问。
      * 但是它又和字面值不同，字面值一定是一个常量，它不会变。但是表达式的值会在运行时变化。
  
* 常量表达式

  * 仅仅包含常量的表达式，**所以表达式值在编译时就确定了**，之后不会变化，就相当于一个普通的常量。
  * 因为单个常量也是常量表达式，所以后面经常用"常量表达式"代指常量表达式和普通的常量,
  * 同理用表达式代指表达式或者普通变量或者函数调用，本质都是一个可变值。

## 3.2 操作数和操作符

> 表达式的类型主要取决于操作符的类型

#### 3.2.1 操作数

* 所有有值的键都可以作为操作数
* 所以操作数可以是表达式，数值字面值，字符字面值，数值变量，函数调用等等。

#### 3.2.2 操作符

##### 1. 算术运算符

* 算术表达式

  * 算术运算符连接的是算术表达式，**值是实际的结果。**,值得类型是表达式类型转换的公共类型。

* 表

  * | Operator       | Meaning              |
    | -------------- | -------------------- |
    | +, -, * , /, % | 加减乘除，取摸(求余) |

    * 整数除法会截断小数部分。
    * 取余只能用于整型，不能用于浮点型。
      * 当有负整数形式时，余数符号取决于具体硬件。

##### 2. 自增自减运算符

* 表达式的值
  * 前置是变量自增自减后的值，后置是变量自增自减前的值

* 左值
  * 自增自减只能用于变量，不能用于表达式。
  * 因为变量是左值，我们可以修改，表达式值我们无法直接修改，因为其存储对象是匿名的。
* ++， --
  * 自增1，自减1

##### 3. 位运算符

* 表达式的值

  * 实际计算后的结果

* 操作数限制

  * 只能作用于整型操作数

* 表

  * | Operator    | Meaning                                                      |
    | ----------- | ------------------------------------------------------------ |
    | &, \|, ~, ^ | 按位与或非,异或                                              |
    | <<, >>      | 左移右移。左移补0，右移取决于机器，补0逻辑右移，补符号位算术右移。 |

##### 4.关系和逻辑运算符

* 关系表达式

  * 关系和逻辑运算符连接的是逻辑表达式，**值是0或1**，取决于关系的真或假。

* 表

  * | Operator                     | Meaning                                      |
    | ---------------------------- | -------------------------------------------- |
    | >,    >=,   <,   <=,  ==, != | 大于，大于等于，小于，小于等于，等于，不等于 |
    | &&, \|\| , !                 | 与或非                                       |

    * 二元逻辑运算符 &&和||都规定了从左到右的求值顺序并且是短路求值。
      * &&前面为真后面才继续求值，||前面为假后面才继续求值。

##### 5. 赋值运算符

* 赋值表达式

  * 有赋值运算符的是赋值表达式，表达式的值是赋值完成后左操作数的值，类型是左操作数的类型。

* 表

  * | Operator          | Meaning                                                      |
    | ----------------- | ------------------------------------------------------------ |
    | =                 |                                                              |
    | +=, -=, *=, /=,%= | a+=2,以前老是翻译为a=a+2,其实不用翻译，直接理解为a增加2就行了 |
    | <<=,>>=,&=,\|=,^= |                                                              |

##### 6. 条件运算符

* 形式
  * expr1?expr2:expr3
    * expr1为真，执行expr2,为假执行expr3

* 条件表达式
  * 条件运算符参与的是条件表达式，值可能是expr2或expr3的类型。
  * 但是值的类型跟算术表达式差不多，取决于条件表达式整体的转换的公共类型，跟expr1真假无关。
    * 例如expr2值为int型，expr3值为double型，那么最终条件表达式的值类型为double型，与真假无关。

##### 7. 函数调用运算符

##### 8. 数组引用运算符

##### 8. 逗号运算符

* 定义
  * 不是所有的逗号都是逗号运算符，函数参数列表和定义多个变量语句中的逗号就不是。
* 执行
  * 被逗号分隔的一对表达式将按照从左到右的顺序进行求值。

#### 3.2.3 运算符优先级、结合性别与求值顺序

##### 1. 优先级和结合性

* 优先级规定了运算符优先级不同时的计算顺序

* 结合性规定了运算符优先级相同时的计算顺序

  * | Opeator                   | Meaning                                    | 结合性                 |
    | ------------------------- | ------------------------------------------ | ---------------------- |
    | ()    []   ->   .         | 函数调用，访问结构成员                     | 左结合(即从左到右顺序) |
    | !   ~  ++  --  +  -  *  & | 逻辑非，按位取反，正负号，指针访问，取地址 | **右结合**             |
    | *   /      %              | 乘除取余                                   | 左结合                 |
    | +  -                      | 加减                                       | 左结合                 |
    | <<  >>                    | 左右移                                     | 左结合                 |
    | <   <=  > >=              | 小于，小于等于                             | 左结合                 |
    | == !=                     | 等于，不等于                               | 左结合                 |
    | &                         | 按位与                                     | 左结合                 |
    | ^                         | 按位异或                                   | 左结合                 |
    | \|                        | 按位或                                     | 左结合                 |
    | &&                        | 逻辑与                                     | 左结合                 |
    | \|\|                      | 逻辑或                                     | 左结合                 |
    | ?:                        | 条件运算                                   | **右结合**             |
    | =  +=  -=  *=   /= %= &=  | 复合赋值                                   | **右结合**             |
    | ^= \|= <<= >>=            | 复合赋值                                   | 左结合                 |
    | ,                         | 逗号运算符                                 | 左结合                 |

##### 2. 求值顺序

* 二元运算符两边操作数为普通变量，不存在求值问题，直接计算即可。
* 当两边操作数为表达式，那么计算之前就要先求出表达式的值。
  * C语言大部分二元运算符没有规定求值顺序，有可能先求左表达式或右表达式。
  * &&， || 规定从左到右求值，并且&&左边值为真才继续求值，||左边值为假才继续求值。
  * ，运算符从左到右依次求值。
* 应该尽量避免计算结果与求值顺序有关。

## 3.3 类型转换

#### 3.3.1 概念

* 数值类型转换

  * 最常见的类型转换就是数值类型之间的转换。

  * 本质是现在的数值计算都是2的补码表示形式，所以即使表示同一个值，数值类型不同，值的表现形式也不同，所以计算不同类型数时需要首先同意转换为一种数据类型。

* 原变量不变

  * 原变量是不能修改的，所以如何完成数值类型转换，那么就是创建类型为变量要转为的类型的匿名变量并初始化为待转变量的值，然后利用这个匿名对象计算，计算完成后销毁该对象。

  * **切记转换这个词比较有迷惑性，变量是不会变的，所谓转换其实是新建一个和变量值相同但是类型不同的匿名对象完成计算然后销毁**

    * ```c
      int a =10;  long b = 100;
      a+b;
      //a+b这是一个表达式，求值时,需要将a转为long类型，说是这么说的，但是a的值是不会变得。
      //我们都知道，表达式都是有一个值的，这个值得有地方保存，所以一定有一个保存表达式值的匿名对象
      //如果只需要转换一个类型，那么我们就可以利用这个匿名对象，创建一个long匿名对象保存a的值，然后把b加进来就行了。。
      //如果有大于1个的需要类型转换的变量，那么还要创建更多的匿名对象
      ```

#### 3.3.2 分类

##### 1. 自动(隐式)类型转换

* 定义
  * 很多情况下C语言进行自动(隐式)类型转换。
  * 转换的原则一般是"小"转"大"，尽量不损失数值精度。
    * 算术表达式转换一般不损失精度
    * 赋值表达式转换则取决于具体转换
* 分类
  * 算术运算表达式
    * 二元运算符两边操作数要转为同一类型。
    * 转换规则
      * 详细版
        * 见《c语言程序设计第二版》173页附录A.6
      * 如果表达式中不涉及无符号整数，那么用下列规则即可
        * 一个操作数为long double, 另一个也转long double
        * 一个操作数double，另一个也转double
        * 一个操作数为float，另一个也转float
        * char和short操作数都转int(本质是因为最少都是为32位设计的加减乘除)
        * 一个操作数为long，另一个转long
        * 如果一个表达式涉及多种类型参与，那么首先会转换为一个公共类型进行运算。表达式的值的类型将会是这个公共类型。
  * 赋值
    * 赋值号右边表达式的值要转为左边的类型。
    * 赋值表达式，函数参数传递等凡是需要赋值的地方都会隐式类型转换。

##### 2. 强制类型转换

* 定义

  * 强制类型转换，程序员手动强制转换类型

* 用法

  * (类型名) 表达式

    * ```c
      (double)(2+3);
      char a='b';
      (int)a;
      ```

  * 切记类型转换的本质不是修改原来的变量或者表达式，而是新建一个同值的符合类型的匿名对象，然后用完后销毁。

# 4 流程控制

> flow control

## 4.1 条件(condition)

* 条件部分可以是任意表达式
* 判断流程
  * 执行表达式
  * 得到表达式的值
  * 根据表达式值进行条件判断
    * 0表示假
    * 非0表示真

## 4.2 分支

##### 4.2.1 if语句

* 根据测试结果选分支

  * ```c
    if (expression)
      statement;
    else
      statement;
    if (expression)
      statment
    else if(expression)
      statement
    else
    ```

##### 4.2.2 switch语句

* 根据测试结果选分支

  * ```c
    switch(表达式)
    {
          case 常量表达式：语句序列；
          case 常量表达式：语句序列；
          case 常量表达式：语句序列；
          default:语句序列；         
    }
    ```

  * 常量表达式包括常量表达式和普通的常量。
  * 如果没有break，那么匹配case语句后会自动执行下一个；
  * 加break跳出case语句，不执行下一条。
  * 什么都不匹配，那么默认匹配default语句，default语句最好加break，以防后面在加case语句导致不必要的麻烦。

## 4.3 循环

##### 4.3.1 while和for循环

* 先测试，再循环

  * ```c
    while(expr)
      body;
    for(expr1;expr2;expr3)
      body;
    //没有continue情况下，上面的for循环等价于
    expr1;
    while(expr2)
    {
      body;
      expr3;
    }
    
    ```

* 如果有continue，while直接跳到expr2条件测试，而for循环会执行完expr3之后在跳到expr2测试。

* 条件测试为真，执行循环，为假，终止循环。

* for两个分号不能省略，expr1,expr2,expr3都可以省略，

  * **如果expr2为空，那么表示永真**

##### 4.3.2 do-while循环

* 先执行，再测试

  * ```c
    do
    {
        body;
    }while(expr);  //注意这里分号不能省略
    ```


##### 4.3.3 break和continue

* break
  * 用于switch语句跳出当前switch语句
  * 用于循环跳出当前循环语句
    * 如果有多层嵌套循环，那么只能跳出当前一层循环。
* continue
  * 跳过本次循环，进行下一次循环
    * while,do-while
      * 直接跳到条件测试
    * for
      * 执行完本次expr3之后跳到条件测试

##### 4.3.4 goto语句

* ```c
  goto label;
  label:
  ```

  * label代表goto使用的标号。
  * 标识符后面加冒号就组成一个标号。

# 5. 语句与块

### 1.语句

* 每个分号标识一个语句

### 2. 块

* 一对花括号构成一个复合语句(也叫做程序块),语法上等价于一条语句。

# 6 预处理机制

